Effarea[1,]
TotEffmonth
for(i in 2:(length(indyr)))#
{#
	Effarea[i,]<-VBarea[i-1,]/(NationVulB[i-1,indnatarea]+0.000001)*TotEffyear[indyr[i-1],]*TotEffmonth[indmonth[i-1],]#
	for (a in 1:nage)#
	{#
		propVBarea<-vector(length=nareas)#
		for(r in 1:nareas)#
		{#
			propVBarea[r]<-(pnorm(areas[r]+0.5,PosX[i,],varPos)-pnorm(areas[r]-0.5,PosX[i,],varPos))[a]#
		}#
#
		Effage[i,a]<- sum(Effarea[i,]* propVBarea)#
#
	}#
	#Effage[i,]<- Effarea[i-1,PosX[i-1,]+1]#
#
	if(indmonth[i]>1)#
	{#
		Nage[i,]<-Nage[i-1,]*exp(-(m+q*Effage[i,]*va)/12)#
#
	}else{#
		Nage[i,1]<-So*SB[i-nmonths]/(1+beta*SB[i-nmonths])*RelRec[indyr[i]]#
		Nage[i,2:nage]<-Nage[i-1,1:(nage-1)]*exp(-(m+q*Effage[i,1:(nage-1)]+va[1:(nage-1)])/12)#
#
	}#
	VulB[i,]<-Nage[i,]*va*wa#
	SB[i]<-sum(VulB[i,]*fa)/2#
#
	for (r in 1:nareas){#
		VBarea[i,r]<-sum(VulB[i,]*(pnorm(areas[r]+0.5,PosX[i,],varPos)-pnorm(areas[r]-0.5,PosX[i,],varPos)))#
	}#
	NationVulB[i,]<-c(sum(VBarea[i,1:nationareas[1]]),sum(VBarea[i,(nationareas[1]+1):nareas]))	#
#
}
plot((1:(length(indyr)))[1:36],apply(VulB,1,sum)[1:36])
ro<-1000#
h<-0.7#
m<-0.3#
fe<-0#
kappa<-4*h/(1-h)#
q<-1#
#
#vectors#
wa<-c(1.0121,1.3858,1.725,2.0174,2.2609,2.4589,2.6171)#
fa<-c(0.072924,0.66935,1.5841,2.0026,2.2595,2.4588,2.6171)#
va<-c(0.0041512,0.084884,0.60249,1,1,1,1)#
za<-m+va*fe#
#
lx<-vector(length=length(age))#
lx<-exp(-m*age)#
lx[length(age)]<-lx[length(age)]/(1-exp(-m))#
#
#summary vectors#
phie<-sum(lx*fa)#
So<-kappa/phie#
bo<-kappa/So*ro#
beta<-(kappa-1)/bo#
SDR<-1#
#model dims#
age<-1:7; nage<-length(age)#
months<-1:12; nmonths<-length(months)#
years<-1:100; nyears<-length(years)#
ntstp<-nmonths*nyears#
areas<-0:15; nareas<-length(areas)#
nations<-2; nationareas<-c(12,4)#
#annual forcing inputs#
RelRec<-exp(SDR*rnorm(nyears,0,.6))#
TotEffyear<-matrix(c(rep(2,nyears),rep(1,nyears)),ncol=2, byrow=F)#
TotEffmonth<-matrix(c(0,0,0,0.5,1,1,1,1,0.5,0.1,0,0,0,0,0,0,0,1,1,1,0.5,0.3,0.2,0.1),ncol=2, byrow=F)#
minPos<-c(2,2,2,2,2,2,2) #min position in this exalmple is the spawning area so all min positions will bbe set to 0#
maxPos<-c(2,4,6,7,9,9,11) #age based max position#
varPos<-c(.5,1,1,1.2,1.2,1.2,1.5)#
#empty objects#
SB<-vector(length=ntstp)#
NationVulB<-matrix(nrow=ntstp,ncol=nations)#
Nage<-matrix(NA,nrow=ntstp,ncol=nage)#
VulB<-matrix(NA,nrow=ntstp,ncol=nage)#
PosX<-matrix(NA,nrow=ntstp,ncol=nage)#
VBarea<-matrix(NA,nrow=ntstp,ncol=nareas)#
Effarea<-matrix(NA,nrow=ntstp,ncol=nareas)#
Effage<-matrix(NA,nrow=ntstp,ncol=nage)#
#fill in matrices#
#
#indices#
indyr<-rep(years, each=nmonths)#
indmonth<-rep(months,nyears)#
indnatarea<-rep(1:nations,times=nationareas)#
#first row stuff#
Nage[1,1]<-So*bo/(1+beta*bo)#
#numbers and biomass#
for(i in 2:nage)#
{#
	Nage[1,i]<-Nage[1,(i-1)]*exp(-(m+fe*va[i-1]))#
}#
VulB[1,]<-Nage[1,]*va*wa#
SB[1]<-sum(Nage[1,]*wa*fa)/2#
#
#mean positions and biomass by area#
for(i in 1:length(indyr))#
{#
	PosX[i,]<-floor(signif(minPos+(maxPos-minPos)*(0.5+0.5*sin(indmonth[i]*pi/6-pi/2)),0))#
}#
#
#=======================================================================================================#
#plot of age distribution by area in a single year - abundance is not represented here.#
x<-seq(min(areas),max(areas),by=0.1)#
dnorm(x,PosX[1,],1)#
#
cores<-rainbow(nage)#
par(mfrow=c(3,4))#
for(m in 1:12){#
	for( i in 1:(length(PosX[m,]))){#
		plot(x,dnorm(x,PosX[m,i],varPos[i]),type="l", lwd=2, col=cores[i],main=m,xlab="area",ylim=c(0,.8))#
		if(m==1){#
			legend("topright", legend=age,  col = cores, border = "n", lwd=2, bty="n")#
		}#
		##if(m==5){#
		##	polygon(c(x[30:100],x[100]), c(dnorm(x[30:100],PosX[m,4],varPos[4]),0),col="blue")#
		##}#
		par(new=T)#
#
}#
par(new=F)#
}#
#=======================================================================================================#
#
#calculate biomass in around each area x (limits could be set to )#
propVBarea<-matrix(0,nrow=ntstp,ncol=nareas)#
for (r in 1:nareas){#
		VBarea[1,r]<-sum(VulB[1,]*(pnorm(areas[r]+0.5,PosX[1,],varPos)-pnorm(areas[r]-0.5,PosX[1,],varPos)))#
		# biomass at age * proportion of biomass of each age in that area#
		propVBarea[1,]<-propVBarea[1,]+(pnorm(areas[r]+0.5,PosX[1,],varPos)-pnorm(areas[r]-0.5,PosX[1,],varPos))#
	}#
NationVulB[1,]<-c(sum(VBarea[1,1:nationareas[1]]),sum(VBarea[1,(nationareas[1]+1):nareas]))#
#effort#
Effarea[1,]<-VBarea[1,]/(NationVulB[1,indnatarea]+0.000001)*TotEffyear[indyr[1],indnatarea]*TotEffmonth[indmonth[1],indnatarea]#
#Calculate the effort that each class is subject to. weighted average of effort in each area wieghted by the prop of that age class in each area #
for (a in 1:nage){#
	propVBarea<-vector(length=nareas)#
	for(r in 1:nareas){#
		propVBarea[r]<-(pnorm(areas[r]+0.5,PosX[1,],varPos)-pnorm(areas[r]-0.5,PosX[1,],varPos))[a]#
	}#
#
	Effage[1,a]<- sum(Effarea[1,]* propVBarea)#
#
}#
#for(i in 2:(length(indyr)))#
#{#
#	#Effarea[i,]<-VBarea[i-1,]/(NationVulB[i-1,indnatarea]+0.000001)*TotEffyear[indyr[i-1],]*TotEffmonth[indmonth[i-1],]#
##
#	if(indmonth[i]>1)#
#	{#
#		Nage[i,]<-Nage[i-1,]*exp(-(m+q*Effage[i-1,]*va)/12)#
##
#	}else{#
#		Nage[i,1]<-So*SB[i-nmonths]/(1+beta*SB[i-nmonths])*RelRec[indyr[i]]#
#			#
#		Nage[i,2:nage]<-Nage[i-1,1:(nage-1)]*exp(-(m+q*Effage[i-1,1:(nage-1)]+va[1:(nage-1)])/12)#
##
#	}#
#	VulB[i,]<-Nage[i,]*va*wa#
#	SB[i]<-sum(VulB[i,]*fa)/2#
##
#	VBarea[i,]<-calcVBarea(pos=PosX[i,],vulb=VulB[i,])#
##
#	NationVulB[i,]<-c(sum(VBarea[i,1:nationareas[1]]),sum(VBarea[i,(nationareas[1]+1):nareas]))#
##
#	Effarea[i,]<-VBarea[i,]/(NationVulB[i,indnatarea]+0.000001)*TotEffyear[indyr[i],]*TotEffmonth[indmonth[i],]#
#	Effage[i,]<- Effarea[i,PosX[i,]+1]#
##
##
#}#
#
#putting the effort first...  I'm still not sure this makes sense but carl said this was the way I should do it#
for(i in 2:(length(indyr)))#
{#
	Effarea[i,]<-VBarea[i-1,]/(NationVulB[i-1,indnatarea]+0.000001)*TotEffyear[indyr[i-1],]*TotEffmonth[indmonth[i-1],]#
	for (a in 1:nage)#
	{#
		propVBarea<-vector(length=nareas)#
		for(r in 1:nareas)#
		{#
			propVBarea[r]<-(pnorm(areas[r]+0.5,PosX[i,],varPos)-pnorm(areas[r]-0.5,PosX[i,],varPos))[a]#
		}#
#
		Effage[i,a]<- sum(Effarea[i,]* propVBarea)#
#
	}#
	#Effage[i,]<- Effarea[i-1,PosX[i-1,]+1]#
#
	if(indmonth[i]>1)#
	{#
		Nage[i,]<-Nage[i-1,]*exp(-(m+q*Effage[i,]*va)/12)#
#
	}else{#
		Nage[i,1]<-So*SB[i-nmonths]/(1+beta*SB[i-nmonths])*RelRec[indyr[i]]#
		Nage[i,2:nage]<-Nage[i-1,1:(nage-1)]*exp(-(m+q*Effage[i,1:(nage-1)]+va[1:(nage-1)])/12)#
#
	}#
	VulB[i,]<-Nage[i,]*va*wa#
	SB[i]<-sum(VulB[i,]*fa)/2#
#
	for (r in 1:nareas){#
		VBarea[i,r]<-sum(VulB[i,]*(pnorm(areas[r]+0.5,PosX[i,],varPos)-pnorm(areas[r]-0.5,PosX[i,],varPos)))#
	}#
	NationVulB[i,]<-c(sum(VBarea[i,1:nationareas[1]]),sum(VBarea[i,(nationareas[1]+1):nareas]))	#
#
}
plot((1:(length(indyr)))[1:36],apply(VulB,1,sum)[1:36])
Effage[1:36]
Effage[1:36,]
q
exp(-(m+q*Effage[1:36,]*va)/12)
i=13
indmonth[i]>1
So*SB[i-nmonths]/(1+beta*SB[i-nmonths])*RelRec[indyr[i]]
ro<-1000#
h<-0.7#
m<-0.3#
fe<-0#
kappa<-4*h/(1-h)#
q<-1#
#
#vectors#
wa<-c(1.0121,1.3858,1.725,2.0174,2.2609,2.4589,2.6171)#
fa<-c(0.072924,0.66935,1.5841,2.0026,2.2595,2.4588,2.6171)#
va<-c(0.0041512,0.084884,0.60249,1,1,1,1)#
za<-m+va*fe#
#
lx<-vector(length=length(age))#
lx<-exp(-m*age)#
lx[length(age)]<-lx[length(age)]/(1-exp(-m))#
#
#summary vectors#
phie<-sum(lx*fa)#
So<-kappa/phie#
bo<-kappa/So*ro#
beta<-(kappa-1)/bo#
SDR<-1#
#model dims#
age<-1:7; nage<-length(age)#
months<-1:12; nmonths<-length(months)#
years<-1:100; nyears<-length(years)#
ntstp<-nmonths*nyears#
areas<-0:15; nareas<-length(areas)#
nations<-2; nationareas<-c(12,4)#
#annual forcing inputs#
RelRec<-exp(SDR*rnorm(nyears,0,.6))#
TotEffyear<-matrix(c(rep(2,nyears),rep(1,nyears)),ncol=2, byrow=F)#
TotEffmonth<-matrix(c(0,0,0,0.5,1,1,1,1,0.5,0.1,0,0,0,0,0,0,0,1,1,1,0.5,0.3,0.2,0.1),ncol=2, byrow=F)#
minPos<-c(2,2,2,2,2,2,2) #min position in this exalmple is the spawning area so all min positions will bbe set to 0#
maxPos<-c(2,4,6,7,9,9,11) #age based max position#
varPos<-c(.5,1,1,1.2,1.2,1.2,1.5)#
#empty objects#
SB<-vector(length=ntstp)#
NationVulB<-matrix(nrow=ntstp,ncol=nations)#
Nage<-matrix(NA,nrow=ntstp,ncol=nage)#
VulB<-matrix(NA,nrow=ntstp,ncol=nage)#
PosX<-matrix(NA,nrow=ntstp,ncol=nage)#
VBarea<-matrix(NA,nrow=ntstp,ncol=nareas)#
Effarea<-matrix(NA,nrow=ntstp,ncol=nareas)#
Effage<-matrix(NA,nrow=ntstp,ncol=nage)#
#fill in matrices#
#
#indices#
indyr<-rep(years, each=nmonths)#
indmonth<-rep(months,nyears)#
indnatarea<-rep(1:nations,times=nationareas)#
#first row stuff#
Nage[1,1]<-So*bo/(1+beta*bo)#
#numbers and biomass#
for(i in 2:nage)#
{#
	Nage[1,i]<-Nage[1,(i-1)]*exp(-(m+fe*va[i-1]))#
}#
VulB[1,]<-Nage[1,]*va*wa#
SB[1]<-sum(Nage[1,]*wa*fa)/2#
#
#mean positions and biomass by area#
for(i in 1:length(indyr))#
{#
	PosX[i,]<-floor(signif(minPos+(maxPos-minPos)*(0.5+0.5*sin(indmonth[i]*pi/6-pi/2)),0))#
}#
#
#=======================================================================================================#
#plot of age distribution by area in a single year - abundance is not represented here.#
x<-seq(min(areas),max(areas),by=0.1)#
dnorm(x,PosX[1,],1)#
#
cores<-rainbow(nage)#
par(mfrow=c(3,4))#
for(m in 1:12){#
	for( i in 1:(length(PosX[m,]))){#
		plot(x,dnorm(x,PosX[m,i],varPos[i]),type="l", lwd=2, col=cores[i],main=m,xlab="area",ylim=c(0,.8))#
		if(m==1){#
			legend("topright", legend=age,  col = cores, border = "n", lwd=2, bty="n")#
		}#
		##if(m==5){#
		##	polygon(c(x[30:100],x[100]), c(dnorm(x[30:100],PosX[m,4],varPos[4]),0),col="blue")#
		##}#
		par(new=T)#
#
}#
par(new=F)#
}#
#=======================================================================================================#
#
#calculate biomass in around each area x (limits could be set to )#
propVBarea<-matrix(0,nrow=ntstp,ncol=nareas)#
for (r in 1:nareas){#
		VBarea[1,r]<-sum(VulB[1,]*(pnorm(areas[r]+0.5,PosX[1,],varPos)-pnorm(areas[r]-0.5,PosX[1,],varPos)))#
		# biomass at age * proportion of biomass of each age in that area#
		propVBarea[1,]<-propVBarea[1,]+(pnorm(areas[r]+0.5,PosX[1,],varPos)-pnorm(areas[r]-0.5,PosX[1,],varPos))#
	}#
NationVulB[1,]<-c(sum(VBarea[1,1:nationareas[1]]),sum(VBarea[1,(nationareas[1]+1):nareas]))#
#effort#
Effarea[1,]<-VBarea[1,]/(NationVulB[1,indnatarea]+0.000001)*TotEffyear[indyr[1],indnatarea]*TotEffmonth[indmonth[1],indnatarea]#
#Calculate the effort that each class is subject to. weighted average of effort in each area wieghted by the prop of that age class in each area #
for (a in 1:nage){#
	propVBarea<-vector(length=nareas)#
	for(r in 1:nareas){#
		propVBarea[r]<-(pnorm(areas[r]+0.5,PosX[1,],varPos)-pnorm(areas[r]-0.5,PosX[1,],varPos))[a]#
	}#
#
	Effage[1,a]<- sum(Effarea[1,]* propVBarea)#
#
}#
#for(i in 2:(length(indyr)))#
#{#
#	#Effarea[i,]<-VBarea[i-1,]/(NationVulB[i-1,indnatarea]+0.000001)*TotEffyear[indyr[i-1],]*TotEffmonth[indmonth[i-1],]#
##
#	if(indmonth[i]>1)#
#	{#
#		Nage[i,]<-Nage[i-1,]*exp(-(m+q*Effage[i-1,]*va)/12)#
##
#	}else{#
#		Nage[i,1]<-So*SB[i-nmonths]/(1+beta*SB[i-nmonths])*RelRec[indyr[i]]#
#			#
#		Nage[i,2:nage]<-Nage[i-1,1:(nage-1)]*exp(-(m+q*Effage[i-1,1:(nage-1)]+va[1:(nage-1)])/12)#
##
#	}#
#	VulB[i,]<-Nage[i,]*va*wa#
#	SB[i]<-sum(VulB[i,]*fa)/2#
##
#	VBarea[i,]<-calcVBarea(pos=PosX[i,],vulb=VulB[i,])#
##
#	NationVulB[i,]<-c(sum(VBarea[i,1:nationareas[1]]),sum(VBarea[i,(nationareas[1]+1):nareas]))#
##
#	Effarea[i,]<-VBarea[i,]/(NationVulB[i,indnatarea]+0.000001)*TotEffyear[indyr[i],]*TotEffmonth[indmonth[i],]#
#	Effage[i,]<- Effarea[i,PosX[i,]+1]#
##
##
#}#
#
#putting the effort first...  I'm still not sure this makes sense but carl said this was the way I should do it#
for(i in 2:(length(indyr)))#
{#
	Effarea[i,]<-VBarea[i-1,]/(NationVulB[i-1,indnatarea]+0.000001)*TotEffyear[indyr[i-1],]*TotEffmonth[indmonth[i-1],]#
	for (a in 1:nage)#
	{#
		propVBarea<-vector(length=nareas)#
		for(r in 1:nareas)#
		{#
			propVBarea[r]<-(pnorm(areas[r]+0.5,PosX[i,],varPos)-pnorm(areas[r]-0.5,PosX[i,],varPos))[a]#
		}#
#
		Effage[i,a]<- sum(Effarea[i,]* propVBarea)#
#
	}#
	#Effage[i,]<- Effarea[i-1,PosX[i-1,]+1]#
#
	if(indmonth[i]>1)#
	{#
		Nage[i,]<-Nage[i-1,]*exp(-(m+q*Effage[i,]*va)/12)#
#
	}else{#
		Nage[i,1]<-So*SB[i-nmonths]/(1+beta*SB[i-nmonths])*RelRec[indyr[i]]#
		Nage[i,2:nage]<-Nage[i-1,1:(nage-1)]*exp(-(m+q*Effage[i,1:(nage-1)]*va[1:(nage-1)])/12)#
#
	}#
	VulB[i,]<-Nage[i,]*va*wa#
	SB[i]<-sum(VulB[i,]*fa)/2#
#
	for (r in 1:nareas){#
		VBarea[i,r]<-sum(VulB[i,]*(pnorm(areas[r]+0.5,PosX[i,],varPos)-pnorm(areas[r]-0.5,PosX[i,],varPos)))#
	}#
	NationVulB[i,]<-c(sum(VBarea[i,1:nationareas[1]]),sum(VBarea[i,(nationareas[1]+1):nareas]))	#
#
}
plot((1:(length(indyr)))[1:36],apply(VulB,1,sum)[1:36])
Nage[1:12,1]
Nage[1:12,]
m
ro<-1000#
h<-0.7#
m<-0.3#
fe<-0#
kappa<-4*h/(1-h)#
q<-1#
#
#vectors#
wa<-c(1.0121,1.3858,1.725,2.0174,2.2609,2.4589,2.6171)#
fa<-c(0.072924,0.66935,1.5841,2.0026,2.2595,2.4588,2.6171)#
va<-c(0.0041512,0.084884,0.60249,1,1,1,1)#
za<-m+va*fe#
#
lx<-vector(length=length(age))#
lx<-exp(-m*age)#
lx[length(age)]<-lx[length(age)]/(1-exp(-m))#
#
#summary vectors#
phie<-sum(lx*fa)#
So<-kappa/phie#
bo<-kappa/So*ro#
beta<-(kappa-1)/bo#
SDR<-1#
#model dims#
age<-1:7; nage<-length(age)#
months<-1:12; nmonths<-length(months)#
years<-1:100; nyears<-length(years)#
ntstp<-nmonths*nyears#
areas<-0:15; nareas<-length(areas)#
nations<-2; nationareas<-c(12,4)#
#annual forcing inputs#
RelRec<-exp(SDR*rnorm(nyears,0,.6))#
TotEffyear<-matrix(c(rep(2,nyears),rep(1,nyears)),ncol=2, byrow=F)#
TotEffmonth<-matrix(c(0,0,0,0.5,1,1,1,1,0.5,0.1,0,0,0,0,0,0,0,1,1,1,0.5,0.3,0.2,0.1),ncol=2, byrow=F)#
minPos<-c(2,2,2,2,2,2,2) #min position in this exalmple is the spawning area so all min positions will bbe set to 0#
maxPos<-c(2,4,6,7,9,9,11) #age based max position#
varPos<-c(.5,1,1,1.2,1.2,1.2,1.5)#
#empty objects#
SB<-vector(length=ntstp)#
NationVulB<-matrix(nrow=ntstp,ncol=nations)#
Nage<-matrix(NA,nrow=ntstp,ncol=nage)#
VulB<-matrix(NA,nrow=ntstp,ncol=nage)#
PosX<-matrix(NA,nrow=ntstp,ncol=nage)#
VBarea<-matrix(NA,nrow=ntstp,ncol=nareas)#
Effarea<-matrix(NA,nrow=ntstp,ncol=nareas)#
Effage<-matrix(NA,nrow=ntstp,ncol=nage)#
#fill in matrices#
#
#indices#
indyr<-rep(years, each=nmonths)#
indmonth<-rep(months,nyears)#
indnatarea<-rep(1:nations,times=nationareas)#
#first row stuff#
Nage[1,1]<-So*bo/(1+beta*bo)#
#numbers and biomass#
for(i in 2:nage)#
{#
	Nage[1,i]<-Nage[1,(i-1)]*exp(-(m+fe*va[i-1]))#
}#
VulB[1,]<-Nage[1,]*va*wa#
SB[1]<-sum(Nage[1,]*wa*fa)/2#
#
#mean positions and biomass by area#
for(i in 1:length(indyr))#
{#
	PosX[i,]<-floor(signif(minPos+(maxPos-minPos)*(0.5+0.5*sin(indmonth[i]*pi/6-pi/2)),0))#
}#
#
#=======================================================================================================#
#plot of age distribution by area in a single year - abundance is not represented here.#
x<-seq(min(areas),max(areas),by=0.1)#
dnorm(x,PosX[1,],1)#
#
cores<-rainbow(nage)#
par(mfrow=c(3,4))#
for(mth in 1:12){#
	for( i in 1:(length(PosX[mth,]))){#
		plot(x,dnorm(x,PosX[mth,i],varPos[i]),type="l", lwd=2, col=cores[i],main=mth,xlab="area",ylim=c(0,.8))#
		if(mth==1){#
			legend("topright", legend=age,  col = cores, border = "n", lwd=2, bty="n")#
		}#
		##if(m==5){#
		##	polygon(c(x[30:100],x[100]), c(dnorm(x[30:100],PosX[mth,4],varPos[4]),0),col="blue")#
		##}#
		par(new=T)#
#
}#
par(new=F)#
}#
#=======================================================================================================#
#
#calculate biomass in around each area x (limits could be set to )#
propVBarea<-matrix(0,nrow=ntstp,ncol=nareas)#
for (r in 1:nareas){#
		VBarea[1,r]<-sum(VulB[1,]*(pnorm(areas[r]+0.5,PosX[1,],varPos)-pnorm(areas[r]-0.5,PosX[1,],varPos)))#
		# biomass at age * proportion of biomass of each age in that area#
		propVBarea[1,]<-propVBarea[1,]+(pnorm(areas[r]+0.5,PosX[1,],varPos)-pnorm(areas[r]-0.5,PosX[1,],varPos))#
	}#
NationVulB[1,]<-c(sum(VBarea[1,1:nationareas[1]]),sum(VBarea[1,(nationareas[1]+1):nareas]))#
#effort#
Effarea[1,]<-VBarea[1,]/(NationVulB[1,indnatarea]+0.000001)*TotEffyear[indyr[1],indnatarea]*TotEffmonth[indmonth[1],indnatarea]#
#Calculate the effort that each class is subject to. weighted average of effort in each area wieghted by the prop of that age class in each area #
for (a in 1:nage){#
	propVBarea<-vector(length=nareas)#
	for(r in 1:nareas){#
		propVBarea[r]<-(pnorm(areas[r]+0.5,PosX[1,],varPos)-pnorm(areas[r]-0.5,PosX[1,],varPos))[a]#
	}#
#
	Effage[1,a]<- sum(Effarea[1,]* propVBarea)#
#
}#
#for(i in 2:(length(indyr)))#
#{#
#	#Effarea[i,]<-VBarea[i-1,]/(NationVulB[i-1,indnatarea]+0.000001)*TotEffyear[indyr[i-1],]*TotEffmonth[indmonth[i-1],]#
##
#	if(indmonth[i]>1)#
#	{#
#		Nage[i,]<-Nage[i-1,]*exp(-(m+q*Effage[i-1,]*va)/12)#
##
#	}else{#
#		Nage[i,1]<-So*SB[i-nmonths]/(1+beta*SB[i-nmonths])*RelRec[indyr[i]]#
#			#
#		Nage[i,2:nage]<-Nage[i-1,1:(nage-1)]*exp(-(m+q*Effage[i-1,1:(nage-1)]+va[1:(nage-1)])/12)#
##
#	}#
#	VulB[i,]<-Nage[i,]*va*wa#
#	SB[i]<-sum(VulB[i,]*fa)/2#
##
#	VBarea[i,]<-calcVBarea(pos=PosX[i,],vulb=VulB[i,])#
##
#	NationVulB[i,]<-c(sum(VBarea[i,1:nationareas[1]]),sum(VBarea[i,(nationareas[1]+1):nareas]))#
##
#	Effarea[i,]<-VBarea[i,]/(NationVulB[i,indnatarea]+0.000001)*TotEffyear[indyr[i],]*TotEffmonth[indmonth[i],]#
#	Effage[i,]<- Effarea[i,PosX[i,]+1]#
##
##
#}#
#
#putting the effort first...  I'm still not sure this makes sense but carl said this was the way I should do it#
for(i in 2:(length(indyr)))#
{#
	Effarea[i,]<-VBarea[i-1,]/(NationVulB[i-1,indnatarea]+0.000001)*TotEffyear[indyr[i-1],]*TotEffmonth[indmonth[i-1],]#
	for (a in 1:nage)#
	{#
		propVBarea<-vector(length=nareas)#
		for(r in 1:nareas)#
		{#
			propVBarea[r]<-(pnorm(areas[r]+0.5,PosX[i,],varPos)-pnorm(areas[r]-0.5,PosX[i,],varPos))[a]#
		}#
#
		Effage[i,a]<- sum(Effarea[i,]* propVBarea)#
#
	}#
	#Effage[i,]<- Effarea[i-1,PosX[i-1,]+1]#
#
	if(indmonth[i]>1)#
	{#
		Nage[i,]<-Nage[i-1,]*exp(-(m+q*Effage[i,]*va)/12)#
#
	}else{#
		Nage[i,1]<-So*SB[i-nmonths]/(1+beta*SB[i-nmonths])*RelRec[indyr[i]]#
		Nage[i,2:nage]<-Nage[i-1,1:(nage-1)]*exp(-(m+q*Effage[i,1:(nage-1)]*va[1:(nage-1)])/12)#
#
	}#
	VulB[i,]<-Nage[i,]*va*wa#
	SB[i]<-sum(VulB[i,]*fa)/2#
#
	for (r in 1:nareas){#
		VBarea[i,r]<-sum(VulB[i,]*(pnorm(areas[r]+0.5,PosX[i,],varPos)-pnorm(areas[r]-0.5,PosX[i,],varPos)))#
	}#
	NationVulB[i,]<-c(sum(VBarea[i,1:nationareas[1]]),sum(VBarea[i,(nationareas[1]+1):nareas]))	#
#
}
plot((1:(length(indyr)))[1:36],apply(VulB,1,sum)[1:36])
plot((1:(length(indyr))),apply(VulB,1,sum), type="b")
plot((1:(length(indyr))),apply(VulB,1,sum), type="l")
library(ggplot2)#
library(reshape2)
effageplot<-melt(Effage) #
names(effageplot) <- c("time", "age", "effort")
v <- ggplot(effageplot, aes(time, age, z = effort)) + theme_bw()#
v <- v +  stat_contour(aes(colour=..level..,fill=..level..)) #
v <- v + stat_contour(geom="polygon", aes(fill=..level..))#
v
12*30
12*40
effageplot<-melt(Effage[361:480]) #
names(effageplot) <- c("time", "age", "effort") #
#
v <- ggplot(effageplot, aes(time, age, z = effort)) + theme_bw()#
v <- v +  stat_contour(aes(colour=..level..,fill=..level..)) #
v <- v + stat_contour(geom="polygon", aes(fill=..level..))#
v
effageplot<-melt(Effage[361:480])
names(effageplot) <- c("time", "age", "effort")
Effage[361:480]
effageplot<-melt(Effage[361:480,])
names(effageplot) <- c("time", "age", "effort")
v <- ggplot(effageplot, aes(time, age, z = effort)) + theme_bw()#
v <- v +  stat_contour(aes(colour=..level..,fill=..level..)) #
v <- v + stat_contour(geom="polygon", aes(fill=..level..))#
v
plot((1:(length(indyr))),apply(VulB,1,sum), type="l")
12*28
12*27
12*39
12*38
12*36
effageplot<-melt(Effage[325:432,]) #
names(effageplot) <- c("time", "age", "effort") #
#
v <- ggplot(effageplot, aes(time, age, z = effort)) + theme_bw()#
v <- v +  stat_contour(aes(colour=..level..,fill=..level..)) #
v <- v + stat_contour(geom="polygon", aes(fill=..level..))#
v
df<-data.frame(time=rep(1:length(indyr),3),Abundance=c(SB,apply(VulB,1,sum),apply(Nage,1,sum)),type=rep(c("SB","VB","N"),each=ntstp))#
#
p <- ggplot(df, aes(x=time,y=Abundance,group=type)) + theme_bw()#
p <- p+ geom_line(aes(colour=type),size=2)#
p#
#
multiplot(v,p,cols=1)#
#
#plot biomass by area#
#
VBareaplot<-melt(VBarea) #
names(VBareaplot) <- c("time", "area", "VB")#
p1 <- ggplot(VBareaplot, aes(time, area, z = VB)) + theme_bw()#
p1 <- p1 +  stat_contour(aes(colour=..level..,fill=..level..))+ scale_fill_gradient(low = "olivedrab3", high = "magenta3")#
p1 <- p1 + stat_contour(geom="polygon", aes(fill=..level..,colour=..level..))+ scale_colour_gradient(low = "olivedrab3", high = "magenta3")#
#p1 <- p1 + scale_colour_gradient(low = "olivedrab3", high = "magenta3")#
p1#
#
multiplot(p1,p,cols=1)
multiplot(p1,p,cols=1)
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
multiplot(p1,p,cols=1)
library(maps)#
library(mapdata)#
library(mapproj)#
library(plotrix)#
pdf("westcoast.pdf", width=5, height=7)#
#
par(mfrow=c(1,1), las=1)#
#unprojected map#
plot(0, type="n", xlim=c(-135, -115), ylim=c(30, 55), xaxs="i", yaxs="i", xlab=expression(paste("Longitude (" * degree,")")), ylab=expression(paste("Latitude (" * degree,")")))#
map("worldHires","Canada",xlim=c(-133,-112),ylim=c(30,55), col="gray80", interior=F, fill=T,add=T, boundary=T,resolution=0)#
map("worldHires","Canada",xlim=c(-133,-112),ylim=c(30,55), col="white", interior=F, fill=F,add=T, boundary=T,resolution=0)#
map("worldHires","USA",xlim=c(-133,-112),ylim=c(30,55), col="gray80",fill=T, add=T, boundary=F,resolution=0)#
map("worldHires","USA",xlim=c(-133,-112),ylim=c(30,55), col="white",fill=F, add=T, boundary=T,resolution=0) #
map("state",xlim=c(-133,-112),ylim=c(30,55),col="white",fill=F, add=T, boundary=T,resolution=0)#
map("worldHires","Mexico",xlim=c(-133,-112),ylim=c(30,55), col="gray80",fill=T, add=T, boundary=F,resolution=0) #
map("worldHires","Mexico",xlim=c(-133,-112),ylim=c(30,55), col="white",fill=F, add=T, boundary=T,resolution=0)#
text(-119.5,49.5,"Canada")#
text(-119.5,48.5,"USA")#
text(-116,33,"USA")#
text(-116,32,"Mexico")#
points(c(-123.3657),c(48.4222), cex=1.2)#
points(c(-123.3657,-123.1000),c(48.4222,49.2500),pch=16,cex=.9)#
text(c(-122.5,-121.9),c(48.4222,49.2500),c("Victoria","Vancouver"),cex=.7)
par(mfrow=c(1,1), las=1)#
#unprojected map#
plot(0, type="n", xlim=c(-135, -115), ylim=c(30, 55), xaxs="i", yaxs="i", xlab=expression(paste("Longitude (" * degree,")")), ylab=expression(paste("Latitude (" * degree,")")))#
map("worldHires","Canada",xlim=c(-133,-112),ylim=c(30,55), col="gray80", interior=F, fill=T,add=T, boundary=T,resolution=0)#
map("worldHires","Canada",xlim=c(-133,-112),ylim=c(30,55), col="white", interior=F, fill=F,add=T, boundary=T,resolution=0)#
map("worldHires","USA",xlim=c(-133,-112),ylim=c(30,55), col="gray80",fill=T, add=T, boundary=F,resolution=0)#
map("worldHires","USA",xlim=c(-133,-112),ylim=c(30,55), col="white",fill=F, add=T, boundary=T,resolution=0) #
map("state",xlim=c(-133,-112),ylim=c(30,55),col="white",fill=F, add=T, boundary=T,resolution=0)#
map("worldHires","Mexico",xlim=c(-133,-112),ylim=c(30,55), col="gray80",fill=T, add=T, boundary=F,resolution=0) #
map("worldHires","Mexico",xlim=c(-133,-112),ylim=c(30,55), col="white",fill=F, add=T, boundary=T,resolution=0)#
text(-119.5,49.5,"Canada")#
text(-119.5,48.5,"USA")#
text(-116,33,"USA")#
text(-116,32,"Mexico")#
points(c(-123.3657),c(48.4222), cex=1.2)#
points(c(-123.3657,-123.1000),c(48.4222,49.2500),pch=16,cex=.9)#
text(c(-122.5,-121.9),c(48.4222,49.2500),c("Victoria","Vancouver"),cex=.7)
plot(0, type="n", xlim=c(-135, -115), ylim=c(30, 55), xaxs="i", yaxs="i", xlab=expression(paste("Longitude (" * degree,")")), ylab=expression(paste("Latitude (" * degree,")")))#
map("worldHires","Canada",xlim=c(-133,-112),ylim=c(30,55), col="gray80", interior=F, fill=T,add=T, boundary=T,resolution=0)#
map("worldHires","Canada",xlim=c(-133,-112),ylim=c(30,55), col="white", interior=F, fill=F,add=T, boundary=T,resolution=0)#
map("worldHires","USA",xlim=c(-133,-112),ylim=c(30,55), col="gray80",fill=T, add=T, boundary=F,resolution=0)#
map("worldHires","USA",xlim=c(-133,-112),ylim=c(30,55), col="white",fill=F, add=T, boundary=T,resolution=0) #
map("state",xlim=c(-133,-112),ylim=c(30,55),col="white",fill=F, add=T, boundary=T,resolution=0)#
map("worldHires","Mexico",xlim=c(-133,-112),ylim=c(30,55), col="gray80",fill=T, add=T, boundary=F,resolution=0) #
map("worldHires","Mexico",xlim=c(-133,-112),ylim=c(30,55), col="white",fill=F, add=T, boundary=T,resolution=0)
50/7
log(80.4)
log(.16)
7500-4.376.55
7500-4376.55
650*12
650*14
650*13
381+258
1/208.33
1/ 350.65
120/15
58
log(56)/log(4)
log(56/4)
notas<-scan()
hist(notas)
c(33.5,33.5,33.5,33.5,33.5,33.5,33.5)*0.1
2000?2009
2000:2009
2009-2000
2014-2009
2009:2014
x<- matrix(NA, ncol=7,nrow=6)
x[,4]<-1
x
as.data.frame(x)
a<-rep("a",6)
x<-as.data.frame(x)
x[,7]<-a
x
r=.3
K=1000
t=20
B r<-.3#
  K<-1000#
 t<-20#
 Bo<-K#
#
 B<-numeric()#
 It<-numeric()#
#
 B[1]<-Bo#
 C[1:t]<-10#
#
 for(i in 1:20){#
#
 B[i+1]<-B[i]+rB[i]*(1-B[i]/K)-C[i]#
 It[i]<-0.01*B[i]*exp(rnorm(1,0,.2))#
#
 }
r<-.3#
  K<-1000#
 t<-20#
 Bo<-K#
#
 B<-numeric()#
 It<-numeric()#
#
 B[1]<-Bo#
 C[1:t]<-10#
#
 for(i in 1:20){#
#
 B[i+1]<-B[i]+r*B[i]*(1-B[i]/K)-C[i]#
 It[i]<-0.01*B[i]*exp(rnorm(1,0,.2))#
#
 }
r<-.3#
  K<-1000#
 t<-20#
 Bo<-K#
#
 B<-numeric()#
 It<-numeric()#
 Ct<-numeric()#
#
 B[1]<-Bo#
 Ct[1:t]<-10#
#
 for(i in 1:20){#
#
 B[i+1]<-B[i]+r*B[i]*(1-B[i]/K)-Ct[i]#
 It[i]<-0.01*B[i]*exp(rnorm(1,0,.2))#
#
 }
B
r<-.3#
  K<-1000#
 t<-20#
 Bo<-K#
#
 B<-numeric()#
 It<-numeric()#
 Ct<-numeric()#
#
 B[1]<-Bo#
 Ct[1:5]<-5#
 Ct[6:15]<-15#
 Ct[6:15]<-10#
 for(i in 1:20){#
#
 B[i+1]<-B[i]+r*B[i]*(1-B[i]/K)-Ct[i]#
 It[i]<-0.01*B[i]*exp(rnorm(1,0,.2))#
#
 }
B
r<-.3#
  K<-1000#
 t<-20#
 Bo<-K#
#
 B<-numeric()#
 It<-numeric()#
 Ct<-numeric()#
#
 B[1]<-Bo#
 Ct[1:5]<-5#
 Ct[6:15]<-15#
 Ct[16:t]<-10#
 for(i in 1:20){#
#
 B[i+1]<-B[i]+r*B[i]*(1-B[i]/K)-Ct[i]#
 It[i]<-0.01*B[i]*exp(rnorm(1,0,.2))#
#
 }
B
plot(1:21,B)
?optim
SPfunc<-function(p){#
#
Best<-numeric()#
IT<-numeric()#
Ctrep<-Ct*2#
#
for(i in 1:20){#
#
 Best[i+1]<-Best[i]+r*Best[i]*(1-Best[i]/K)-Ctrep[i]#
 IT[i]<-0.01*Best[i]#
#
 }#
#
SS<-sum((log(IT)-log(It))^2)#
return(SS)#
#
}#
#
param<-c(0.3,1000)#
#
optim(param,SPfunc)
SPfunc<-function(p){#
#
Best<-numeric()#
IT<-numeric()#
Ctrep<-Ct*2#
#
r<-p[1]#
K<-p[2]#
#
for(i in 1:20){#
#
 Best[i+1]<-Best[i]+r*Best[i]*(1-Best[i]/K)-Ctrep[i]#
 IT[i]<-0.01*Best[i]#
#
 }#
#
SS<-sum((log(IT)-log(It))^2)#
return(SS)#
#
}
param<-c(0.3,1000)#
#
optim(param,SPfunc)
SPfunc(param)
It
IT
SPfunc<-function(p){#
#
Best<-numeric()#
IT<-numeric()#
Ctrep<-Ct*2#
#
r<-p[1]#
K<-p[2]#
#
for(i in 1:20){#
#
 Best[i+1]<-Best[i]+r*Best[i]*(1-Best[i]/K)-Ctrep[i]#
 IT[i]<-0.01*Best[i]#
#
 }#
#
SS<-sum((log(IT)-log(It))^2)#
return(SS)#
#
}
SPfunc(param)
param
Best<-numeric()#
IT<-numeric()#
Ctrep<-Ct*2#
#
r<-p[1]#
K<-p[2]#
#
for(i in 1:20){#
#
 Best[i+1]<-Best[i]+r*Best[i]*(1-Best[i]/K)-Ctrep[i]#
 IT[i]<-0.01*Best[i]#
#
 }#
#
SS<-sum((log(IT)-log(It))^2)
SS
(log(IT)-log(It)
)
IT
Best
SPfunc<-function(p){#
#
Best<-numeric()#
IT<-numeric()#
Ctrep<-Ct*2#
#
r<-p[1]#
K<-p[2]#
Best[1]<-K#
for(i in 1:20){#
#
 Best[i+1]<-Best[i]+r*Best[i]*(1-Best[i]/K)-Ctrep[i]#
 IT[i]<-0.01*Best[i]#
#
 }#
#
SS<-sum((log(IT)-log(It))^2)#
return(SS)#
#
}#
#
param<-c(0.3,1000)#
#
SPfunc(param)
optim(param,SPfunc)
warnings
warnings()
param<-c(0.3,000)#
#
SPfunc(param)#
#
optim(param,SPfunc)
SPfunc(param)
param<-c(0.3,3000)
SPfunc(param)
optim(param,SPfunc)
r<-.3#
  K<-1000#
 t<-20#
 Bo<-K#
#
 B<-numeric()#
 It<-numeric()#
 Ct<-numeric()#
#
 B[1]<-Bo#
 Ct[1:5]<-5#
 Ct[6:15]<-15#
 Ct[16:t]<-10#
 for(i in 1:20){#
#
 B[i+1]<-B[i]+r*B[i]*(1-B[i]/K)-Ct[i]#
 It[i]<-0.01*B[i]*exp(rnorm(1,0,.01))#
#
 }#
SPfunc<-function(p){#
#
Best<-numeric()#
IT<-numeric()#
Ctrep<-Ct*2#
#
r<-p[1]#
K<-p[2]#
Best[1]<-K#
for(i in 1:20){#
#
 Best[i+1]<-Best[i]+r*Best[i]*(1-Best[i]/K)-Ctrep[i]#
 IT[i]<-0.01*Best[i]#
#
 }#
#
SS<-sum((log(IT)-log(It))^2)#
return(SS)#
#
}#
#
param<-c(0.3,3000)#
#
SPfunc(param)
optim(param,SPfunc)
plot(1:20,It)
plot(1:20,It,type="b")
p=param
param<-c(0.3,1000)
p=param
Best<-numeric()#
IT<-numeric()#
Ctrep<-Ct*2#
#
r<-p[1]#
K<-p[2]#
Best[1]<-K#
for(i in 1:20){#
#
 Best[i+1]<-Best[i]+r*Best[i]*(1-Best[i]/K)-Ctrep[i]#
 IT[i]<-0.01*Best[i]#
#
 }
IT[
IT
iT
IT
CT
Ct
Ctrep
B<-numeric()#
 It<-numeric()#
 Ct<-numeric()#
#
 B[1]<-Bo#
 Ct[1:5]<-5#
 Ct[6:15]<-15#
 Ct[16:t]<-10#
 for(i in 1:20){#
#
 B[i+1]<-B[i]+r*B[i]*(1-B[i]/K)-Ct[i]#
 It[i]<-0.01*B[i]*exp(rnorm(1,0,.01))#
#
 }
Best<-numeric()#
IT<-numeric()#
Ctrep<-Ct*2#
#
r<-p[1]#
K<-p[2]#
Best[1]<-K#
for(i in 1:20){#
#
 Best[i+1]<-Best[i]+r*Best[i]*(1-Best[i]/K)-Ctrep[i]#
 IT[i]<-0.01*Best[i]#
#
 }
IT
It
SPfunc<-function(p){#
#
Best<-numeric()#
IT<-numeric()#
Ctrep<-Ct*2#
#
r<-p[1]#
K<-p[2]#
Best[1]<-K#
for(i in 1:20){#
#
 Best[i+1]<-Best[i]+r*Best[i]*(1-Best[i]/K)-Ctrep[i]#
 IT[i]<-0.01*Best[i]#
#
 }#
#
SS<-sum((log(IT)-log(It))^2)#
return(SS)#
#
}
param<-c(0.3,1000)
SPfunc(param)
optim(param,SPfunc)
warnings()
SPfunc<-function(p){#
#
Best<-numeric()#
IT<-numeric()#
Ctrep<-Ct*2#
#
r<-p[1]#
K<-p[2]#
q<-p[3]#
Best[1]<-K#
for(i in 1:20){#
#
 Best[i+1]<-Best[i]+r*Best[i]*(1-Best[i]/K)-Ctrep[i]#
 IT[i]<-q*Best[i]#
#
 }#
#
SS<-sum((log(IT)-log(It))^2)#
return(SS)#
#
}#
#
param<-c(0.3,1000,0.01)#
#
SPfunc(param)
optim(param,SPfunc)
Best<-numeric()#
#
Ctrep<-Ct*2#
#
for(i in 1:20){#
#
 Best[i+1]<-Best[i]+rest*Best[i]*(1-Best[i]/Kest)-Ctrep[i]#
#
 }
rest<-res$par[1]#
Kest<-res$par[2]#
qest<res$par[3]#
Best<-numeric()#
#
Ctrep<-Ct*2#
#
for(i in 1:20){#
#
 Best[i+1]<-Best[i]+rest*Best[i]*(1-Best[i]/Kest)-Ctrep[i]#
#
 }
res<-optim(param,SPfunc)#
rest<-res$par[1]#
Kest<-res$par[2]#
qest<res$par[3]#
Best<-numeric()#
#
Ctrep<-Ct*2#
#
for(i in 1:20){#
#
 Best[i+1]<-Best[i]+rest*Best[i]*(1-Best[i]/Kest)-Ctrep[i]#
#
 }
qest<-res$par[3]
plot(1:21,B, type="b",color="hotpink",lwd=2)#
lines(1:21,Best, type="b",lwd=2)
plot(1:21,B, type="b",color="hotpink",lwd=2, ylim(0,2000))#
lines(1:21,Best, type="b",lwd=2)
plot(1:21,B, type="b",color="hotpink",lwd=2, ylim(0,2000))
plot(1:21,B, type="b",color="hotpink",lwd=2, ylim=c(0,2000))
plot(1:21,B, type="b",color="hotpink",lwd=2, ylim=c(800,1200))
plot(1:21,B, type="b",colour="hotpink",lwd=2, ylim=c(800,1200))
plot(1:21,B, type="b",col="hotpink",lwd=2, ylim=c(800,1200))
lines(1:21,Best, type="b",lwd=2)
Best
Best<-numeric()#
#
Ctrep<-Ct*2#
#
for(i in 1:20){#
#
 Best[i+1]<-Best[i]+rest*Best[i]*(1-Best[i]/Kest)-Ctrep[i]#
#
 }
Best
Best<-numeric()#
Best[1]<-Kest#
#
Ctrep<-Ct*2#
#
for(i in 1:20){#
#
 Best[i+1]<-Best[i]+rest*Best[i]*(1-Best[i]/Kest)-Ctrep[i]#
#
 }
Best
plot(1:21,B, type="b",col="hotpink",lwd=2, ylim=c(800,2200))#
lines(1:21,Best, type="b",lwd=2)
Best/B
24*40*50
24*40*52*.7
24*40*52
24*40*52*.8
25*40*52*.8
17.5*40*52*
17.5*40*52
2.200*12
2200*12
26400/36400
24*40*52*.72
xmin=0
t=1:12
xmax=15
vbar=xmin+(xmax-xmin)*(.5+.5*sin(t*2*pi/12-3*2*pi/12))
plot(t,vbar,type="l", lwd=2)
t=1:36
vbar=xmin+(xmax-xmin)*(.5+.5*sin(t*2*pi/12-3*2*pi/12))
plot(t,vbar,type="l", lwd=2)
vbar2=xmin+(xmax-xmin)*(sin(t*2*pi/12-3*2*pi/12))
par(mfrow=c(1,2))
plot(t,vbar,type="l", lwd=2)
plot(t,vbar2,type="l", lwd=2)
(sin(t*2*pi/12-3*2*pi/12))
(.5+.5*sin(t*2*pi/12-3*2*pi/12))
(.5*sin(t*2*pi/12-3*2*pi/12))
(.5*sin(t*2*pi/12))
log(1)
xmin=0
vmax=15
t=1:12
xmin+(xmax-xmin)*(0.5+0.5*sin(2*pi/t))
xmax=15
xmin+(xmax-xmin)*(0.5+0.5*sin(2*pi/t))
curva=xmin+(xmax-xmin)*(0.5+0.5*sin(2*pi/t))
plot(t,curva)
xmin+(xmax-xmin)*(sin(2*pi/t))
curva=xmin+(xmax-xmin)*(sin(2*pi/t))
plot(t,curva)
2*pi/t
curva=xmin+(xmax-xmin)*(0.5+0.5*sin(2*pi*t/12))
plot(t,curva)
curva=xmin+(xmax-xmin)*(0.5*sin(2*pi*t/12))
plot(t,curva)
curva=xmin+(xmax-xmin)*(sin(2*pi*t/12))
plot(t,curva)
curva=xmin+(xmax-xmin)*(0.5*sin(2*pi*t/12))
plot(t,curva)
min(curva)
curva=(xmin+(xmax-xmin))*(0.5*sin(2*pi*t/12))
plot(t,curva)
curva=(xmin+(xmax-xmin))*(0.5+0.5*sin(2*pi*t/12))
plot(t,curva)
min(curva)
curva=(0.5*sin(2*pi*t/12))
plot(t,curva)
17*7
12*12
300/144
rm(list=ls()); #
#if (Sys.info()["nodename"] =="sager")  setwd("~/Dropbox/LSRA/length_SRA/sim_est_lsra")#
setwd("/Users/catarinawor/Documents/length_SRA/simeval/")#
require(PBSmodelling)#
source("read.admb.R")#
Est_Tpl = "jmsra"#
Sim_Tpl = "simsrasp"#
## seed and store input and ouputs#
maxgrad_cr = NULL#
hat_cr = NULL#
ire_cr = NULL#
re_cr = NULL#
maxgrad_h = NULL#
hat_h = NULL#
ire_h = NULL#
re_h = NULL#
nsim = 50#
for(s in 1:nsim) {#
#
##  set seed and Ft  #
#saveSim = paste(Sim_Tpl,'.dat',sep="")#
#cat( file=saveSim, "## written:",date(),"\n", append=T )#
#cat( file=saveSim, "## seed\n", append=T )#
#cat( file=saveSim, seeds[s], "\n", append=T )#
#cat( file=saveSim, "## Ft\n", append=T )#
#cat( file=saveSim, Ft, "\n", append=T )#
#
## run simulator#
system(paste('./',Sim_Tpl,' -ind ',Sim_Tpl,'.dat',sep=""), wait = TRUE)#
input = read.rep("true_data_lsra.rep")#
names(input)#
true_Ro = input$true_Ro#
true_reck = input$true_reck#
true_ct = input$true_Clt#
true_ut = input$true_ut#
#
true_utend = input$true_ut[length(true_ut)]#
true_nat = input$true_Nat#
true_sbt = input$true_sbt#
true_depl = input$true_depl#
true_rt = true_nat[,1]#
true_q = input$true_q#
## run estimator#
system(paste('./',Est_Tpl,' -ind ',Est_Tpl,'.dat',sep=""), wait = TRUE)#
out_cr = read.admb(Est_Tpl)#
names(out_cr)#
## save sim-est outputs#
maxgrad_cr <- rbind(maxgrad_cr, out_cr$fit$maxgrad)#
##print(A$fit$std)#
truePars = c(true_Ro,true_reck,true_depl[length(true_depl)],true_utend,true_q) #need to output q in SRasim#
ihat_cr = c(out_cr$Ro,out_cr$kappa,out_cr$depletion,out_cr$maxUy[length(out_cr$maxUy)],out_cr$q)#
temp_ire_cr = (ihat_cr - truePars) / truePars#
ire_cr <- rbind(ire_cr, temp_ire_cr)#
#
hat_cr <- rbind(hat_cr, ihat_cr)#
#
valid_maxgrad_cr = which(maxgrad_cr <= 0.0001)#
valid_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2)#
valid_grad_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2 & maxgrad_cr <= 0.0001)#
#if(s==nsim) { cat("# Valid Sim=", length(valid_grad_cr)) }#
#
#file.remove("simsra.dat")#
#
}#
#
names(out_cr)#
names(input)#
#
plot_re = function(itheta,ivalid,h_cr,legend=T)  {#
  colnames(itheta) = c("ro","kappa","Depletion","Uend", "q")#
  boxplot(itheta[ivalid,], ylim=c(-0.7,0.7), ylab="relative error", las=1)#
  validSim = length(ivalid)#
  abline(h=0)#
  if(legend == T) {#
    #mtext(side=3,line=0,paste("steepness=",h_cr," Ft=","updowm"," simSigR=",0.6," simSS=","na," trueDepl=", round(trueDepl,2),"\n",#
    #                          "simObsErr=",tau," Mt=",Mtpattern," Vul=",vapattern, " NSim=",validSim,"\n", "cvl=", l1cv," sigVul=", sigVul, #
    #                          " SimRhoR=",round(rhoR,2)," Fmsy=",round(Fmsy,3),"x",xF," true cr/h =",round(cr,3),"/",h ))#
  }#
  else#
    mtext(side=3,line=0,paste("steepness=",h_cr," NSim=",validSim))#
}#
# pdflabel = paste("simF",Ftpattern,"iRE",".pdf",sep="_")#
#
#pdf(file=pdflabel) #
#
par(mfcol=c(1,1),mar=c(4,1,1,1),oma=c(0,2,2.5,0), las=1)#
plot_re(ire_cr,valid_maxgrad_cr,"CR",T)#
#
ire_cr[valid_maxgrad_cr,]
rm(list=ls()); #
#if (Sys.info()["nodename"] =="sager")  setwd("~/Dropbox/LSRA/length_SRA/sim_est_lsra")#
setwd("/Users/catarinawor/Documents/length_SRA/simeval/")#
require(PBSmodelling)#
source("read.admb.R")#
Est_Tpl = "jmsra"#
Sim_Tpl = "simsrasp"#
## seed and store input and ouputs#
maxgrad_cr = NULL#
hat_cr = NULL#
ire_cr = NULL#
re_cr = NULL#
maxgrad_h = NULL#
hat_h = NULL#
ire_h = NULL#
re_h = NULL#
nsim = 1#
for(s in 1:nsim) {#
#
##  set seed and Ft  #
#saveSim = paste(Sim_Tpl,'.dat',sep="")#
#cat( file=saveSim, "## written:",date(),"\n", append=T )#
#cat( file=saveSim, "## seed\n", append=T )#
#cat( file=saveSim, seeds[s], "\n", append=T )#
#cat( file=saveSim, "## Ft\n", append=T )#
#cat( file=saveSim, Ft, "\n", append=T )#
#
## run simulator#
system(paste('./',Sim_Tpl,' -ind ',Sim_Tpl,'.dat',sep=""), wait = TRUE)#
input = read.rep("true_data_lsra.rep")#
names(input)#
true_Ro = input$true_Ro#
true_reck = input$true_reck#
true_ct = input$true_Clt#
true_ut = input$true_ut#
#
true_utend = input$true_ut[length(true_ut)]#
true_nat = input$true_Nat#
true_sbt = input$true_sbt#
true_depl = input$true_depl#
true_rt = true_nat[,1]#
true_q = input$true_q#
## run estimator#
system(paste('./',Est_Tpl,' -ind ',Est_Tpl,'.dat',sep=""), wait = TRUE)#
out_cr = read.admb(Est_Tpl)#
names(out_cr)#
## save sim-est outputs#
maxgrad_cr <- rbind(maxgrad_cr, out_cr$fit$maxgrad)#
##print(A$fit$std)#
truePars = c(true_Ro,true_reck,true_depl[length(true_depl)],true_utend,true_q) #need to output q in SRasim#
ihat_cr = c(out_cr$Ro,out_cr$kappa,out_cr$depletion,out_cr$maxUy[length(out_cr$maxUy)],out_cr$q)#
temp_ire_cr = (ihat_cr - truePars) / truePars#
ire_cr <- rbind(ire_cr, temp_ire_cr)#
#
hat_cr <- rbind(hat_cr, ihat_cr)#
#
valid_maxgrad_cr = which(maxgrad_cr <= 0.0001)#
valid_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2)#
valid_grad_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2 & maxgrad_cr <= 0.0001)#
#if(s==nsim) { cat("# Valid Sim=", length(valid_grad_cr)) }#
#
#file.remove("simsra.dat")#
#
}
system(paste('./',Sim_Tpl,' -ind ',Sim_Tpl,'.dat',sep=""), wait = TRUE)#
input = read.rep("true_data_lsra.rep")#
names(input)#
true_Ro = input$true_Ro#
true_reck = input$true_reck#
true_ct = input$true_Clt#
true_ut = input$true_ut#
#
true_utend = input$true_ut[length(true_ut)]#
true_nat = input$true_Nat#
true_sbt = input$true_sbt#
true_depl = input$true_depl#
true_rt = true_nat[,1]#
true_q = input$true_q#
## run estimator#
system(paste('./',Est_Tpl,' -ind ',Est_Tpl,'.dat',sep=""), wait = TRUE)#
out_cr = read.admb(Est_Tpl)#
names(out_cr)#
## save sim-est outputs#
maxgrad_cr <- rbind(maxgrad_cr, out_cr$fit$maxgrad)#
##print(A$fit$std)#
truePars = c(true_Ro,true_reck,true_depl[length(true_depl)],true_utend,true_q) #need to output q in SRasim#
ihat_cr = c(out_cr$Ro,out_cr$kappa,out_cr$depletion,out_cr$maxUy[length(out_cr$maxUy)],out_cr$q)#
temp_ire_cr = (ihat_cr - truePars) / truePars#
ire_cr <- rbind(ire_cr, temp_ire_cr)#
#
hat_cr <- rbind(hat_cr, ihat_cr)#
#
valid_maxgrad_cr = which(maxgrad_cr <= 0.0001)#
valid_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2)#
valid_grad_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2 & maxgrad_cr <= 0.0001)#
#if(s==nsim) { cat("# Valid Sim=", length(valid_grad_cr)) }
rm(list=ls()); #
#if (Sys.info()["nodename"] =="sager")  setwd("~/Dropbox/LSRA/length_SRA/sim_est_lsra")#
setwd("/Users/catarinawor/Documents/length_SRA/simeval/")#
require(PBSmodelling)#
source("read.admb.R")#
Est_Tpl = "jmsra"#
Sim_Tpl = "simsrasp"#
## seed and store input and ouputs#
maxgrad_cr = NULL#
hat_cr = NULL#
ire_cr = NULL#
re_cr = NULL#
maxgrad_h = NULL#
hat_h = NULL#
ire_h = NULL#
re_h = NULL#
nsim = 1#
#for(s in 1:nsim) {#
#
##  set seed and Ft  #
#saveSim = paste(Sim_Tpl,'.dat',sep="")#
#cat( file=saveSim, "## written:",date(),"\n", append=T )#
#cat( file=saveSim, "## seed\n", append=T )#
#cat( file=saveSim, seeds[s], "\n", append=T )#
#cat( file=saveSim, "## Ft\n", append=T )#
#cat( file=saveSim, Ft, "\n", append=T )#
#
## run simulator#
system(paste('./',Sim_Tpl,' -ind ',Sim_Tpl,'.dat',sep=""), wait = TRUE)#
input = read.rep("true_data_lsra.rep")#
names(input)#
true_Ro = input$true_Ro#
true_reck = input$true_reck#
true_ct = input$true_Clt#
true_ut = input$true_ut#
#
true_utend = input$true_ut[length(true_ut)]#
true_nat = input$true_Nat#
true_sbt = input$true_sbt#
true_depl = input$true_depl#
true_rt = true_nat[,1]#
true_q = input$true_q#
## run estimator#
system(paste('./',Est_Tpl,' -ind ',Est_Tpl,'.dat',sep=""), wait = TRUE)#
out_cr = read.admb(Est_Tpl)#
names(out_cr)#
## save sim-est outputs#
maxgrad_cr <- rbind(maxgrad_cr, out_cr$fit$maxgrad)#
##print(A$fit$std)#
truePars = c(true_Ro,true_reck,true_depl[length(true_depl)],true_utend,true_q) #need to output q in SRasim#
ihat_cr = c(out_cr$Ro,out_cr$kappa,out_cr$depletion,out_cr$maxUy[length(out_cr$maxUy)],out_cr$q)#
temp_ire_cr = (ihat_cr - truePars) / truePars#
ire_cr <- rbind(ire_cr, temp_ire_cr)#
#
hat_cr <- rbind(hat_cr, ihat_cr)#
#
valid_maxgrad_cr = which(maxgrad_cr <= 0.0001)#
valid_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2)#
valid_grad_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2 & maxgrad_cr <= 0.0001)#
#if(s==nsim) { cat("# Valid Sim=", length(valid_grad_cr)) }
rm(list=ls()); #
#if (Sys.info()["nodename"] =="sager")  setwd("~/Dropbox/LSRA/length_SRA/sim_est_lsra")#
setwd("/Users/catarinawor/Documents/length_SRA/simeval/")#
require(PBSmodelling)#
source("read.admb.R")#
Est_Tpl = "jmsra"#
Sim_Tpl = "simsrasp"#
## seed and store input and ouputs#
maxgrad_cr = NULL#
hat_cr = NULL#
ire_cr = NULL#
re_cr = NULL#
maxgrad_h = NULL#
hat_h = NULL#
ire_h = NULL#
re_h = NULL#
nsim = 1#
#for(s in 1:nsim) {#
#
##  set seed and Ft  #
#saveSim = paste(Sim_Tpl,'.dat',sep="")#
#cat( file=saveSim, "## written:",date(),"\n", append=T )#
#cat( file=saveSim, "## seed\n", append=T )#
#cat( file=saveSim, seeds[s], "\n", append=T )#
#cat( file=saveSim, "## Ft\n", append=T )#
#cat( file=saveSim, Ft, "\n", append=T )#
#
## run simulator#
system(paste('./',Sim_Tpl,' -ind ',Sim_Tpl,'.dat',sep=""), wait = TRUE)#
input = read.rep("true_data_lsra.rep")#
names(input)#
true_Ro = input$true_Ro#
true_reck = input$true_reck#
true_ct = input$true_Clt#
true_ut = input$true_ut#
#
true_utend = input$true_ut[length(true_ut)]#
true_nat = input$true_Nat#
true_sbt = input$true_sbt#
true_depl = input$true_depl#
true_rt = true_nat[,1]#
true_q = input$true_q#
## run estimator#
system(paste('./',Est_Tpl,' -ind ',Est_Tpl,'.dat',sep=""), wait = TRUE)#
out_cr = read.admb(Est_Tpl)#
names(out_cr)#
## save sim-est outputs#
maxgrad_cr <- rbind(maxgrad_cr, out_cr$fit$maxgrad)#
##print(A$fit$std)#
truePars = c(true_Ro,true_reck,true_depl[length(true_depl)],true_utend,true_q) #need to output q in SRasim#
ihat_cr = c(out_cr$Ro,out_cr$kappa,out_cr$depletion,out_cr$maxUy[length(out_cr$maxUy)],out_cr$q)#
temp_ire_cr = (ihat_cr - truePars) / truePars#
ire_cr <- rbind(ire_cr, temp_ire_cr)#
#
hat_cr <- rbind(hat_cr, ihat_cr)#
#
valid_maxgrad_cr = which(maxgrad_cr <= 0.0001)#
valid_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2)#
valid_grad_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2 & maxgrad_cr <= 0.0001)#
#if(s==nsim) { cat("# Valid Sim=", length(valid_grad_cr)) }
par(mfcol=c(1,1),mar=c(4,1,1,1),oma=c(0,2,2.5,0), las=1)#
plot_re(ire_cr,valid_maxgrad_cr,"CR",T)
colnames(ire_cr) = c("ro","kappa","Depletion","Uend", "q")#
barplot(ire_cr, ylim=c(-0.7,0.7), ylab="relative error", las=1)
rm(list=ls()); #
#if (Sys.info()["nodename"] =="sager")  setwd("~/Dropbox/LSRA/length_SRA/sim_est_lsra")#
setwd("/Users/catarinawor/Documents/length_SRA/simeval/")#
require(PBSmodelling)#
source("read.admb.R")#
Est_Tpl = "jmsra"#
Sim_Tpl = "simsra"#
## seed and store input and ouputs#
maxgrad_cr = NULL#
hat_cr = NULL#
ire_cr = NULL#
re_cr = NULL#
maxgrad_h = NULL#
hat_h = NULL#
ire_h = NULL#
re_h = NULL#
nsim = 1#
#for(s in 1:nsim) {#
#
##  set seed and Ft  #
#saveSim = paste(Sim_Tpl,'.dat',sep="")#
#cat( file=saveSim, "## written:",date(),"\n", append=T )#
#cat( file=saveSim, "## seed\n", append=T )#
#cat( file=saveSim, seeds[s], "\n", append=T )#
#cat( file=saveSim, "## Ft\n", append=T )#
#cat( file=saveSim, Ft, "\n", append=T )#
#
## run simulator#
system(paste('./',Sim_Tpl,' -ind ',Sim_Tpl,'.dat',sep=""), wait = TRUE)#
input = read.rep("true_data_lsra.rep")#
names(input)#
true_Ro = input$true_Ro#
true_reck = input$true_reck#
true_ct = input$true_Clt#
true_ut = input$true_ut#
#
true_utend = input$true_ut[length(true_ut)]#
true_nat = input$true_Nat#
true_sbt = input$true_sbt#
true_depl = input$true_depl#
true_rt = true_nat[,1]#
true_q = input$true_q#
## run estimator#
system(paste('./',Est_Tpl,' -ind ',Est_Tpl,'.dat',sep=""), wait = TRUE)#
out_cr = read.admb(Est_Tpl)#
names(out_cr)#
## save sim-est outputs#
maxgrad_cr <- rbind(maxgrad_cr, out_cr$fit$maxgrad)#
##print(A$fit$std)#
truePars = c(true_Ro,true_reck,true_depl[length(true_depl)],true_utend,true_q) #need to output q in SRasim#
ihat_cr = c(out_cr$Ro,out_cr$kappa,out_cr$depletion,out_cr$maxUy[length(out_cr$maxUy)],out_cr$q)#
temp_ire_cr = (ihat_cr - truePars) / truePars#
ire_cr <- rbind(ire_cr, temp_ire_cr)#
#
hat_cr <- rbind(hat_cr, ihat_cr)#
#
valid_maxgrad_cr = which(maxgrad_cr <= 0.0001)#
valid_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2)#
valid_grad_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2 & maxgrad_cr <= 0.0001)#
#if(s==nsim) { cat("# Valid Sim=", length(valid_grad_cr)) }#
#
#file.remove("simsra.dat")#
#
#}#
#
names(out_cr)#
names(input)#
#
plot_re = function(itheta,ivalid,h_cr,legend=T)  {#
  colnames(itheta) = c("ro","kappa","Depletion","Uend", "q")#
  boxplot(itheta[ivalid,], ylim=c(-0.7,0.7), ylab="relative error", las=1)#
  validSim = length(ivalid)#
  abline(h=0)#
  if(legend == T) {#
    #mtext(side=3,line=0,paste("steepness=",h_cr," Ft=","updowm"," simSigR=",0.6," simSS=","na," trueDepl=", round(trueDepl,2),"\n",#
    #                          "simObsErr=",tau," Mt=",Mtpattern," Vul=",vapattern, " NSim=",validSim,"\n", "cvl=", l1cv," sigVul=", sigVul, #
    #                          " SimRhoR=",round(rhoR,2)," Fmsy=",round(Fmsy,3),"x",xF," true cr/h =",round(cr,3),"/",h ))#
  }#
  else#
    mtext(side=3,line=0,paste("steepness=",h_cr," NSim=",validSim))#
}
colnames(ire_cr) = c("ro","kappa","Depletion","Uend", "q")#
barplot(ire_cr, ylim=c(-0.7,0.7), ylab="relative error", las=1)
system(paste('./',Sim_Tpl,' -ind ',Sim_Tpl,'.dat',sep=""), wait = TRUE)#
input = read.rep("true_data_lsra.rep")#
names(input)#
true_Ro = input$true_Ro#
true_reck = input$true_reck#
true_ct = input$true_Clt#
true_ut = input$true_ut#
#
true_utend = input$true_ut[length(true_ut)]#
true_nat = input$true_Nat#
true_sbt = input$true_sbt#
true_depl = input$true_depl#
true_rt = true_nat[,1]#
true_q = input$true_q#
## run estimator#
system(paste('./',Est_Tpl,' -ind ',Est_Tpl,'.dat',sep=""), wait = TRUE)#
out_cr = read.admb(Est_Tpl)#
names(out_cr)#
## save sim-est outputs#
maxgrad_cr <- rbind(maxgrad_cr, out_cr$fit$maxgrad)#
##print(A$fit$std)#
truePars = c(true_Ro,true_reck,true_depl[length(true_depl)],true_utend,true_q) #need to output q in SRasim#
ihat_cr = c(out_cr$Ro,out_cr$kappa,out_cr$depletion,out_cr$maxUy[length(out_cr$maxUy)],out_cr$q)#
temp_ire_cr = (ihat_cr - truePars) / truePars#
ire_cr <- rbind(ire_cr, temp_ire_cr)#
#
hat_cr <- rbind(hat_cr, ihat_cr)#
#
valid_maxgrad_cr = which(maxgrad_cr <= 0.0001)#
valid_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2)#
valid_grad_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2 & maxgrad_cr <= 0.0001)#
#if(s==nsim) { cat("# Valid Sim=", length(valid_grad_cr)) }
colnames(ire_cr) = c("ro","kappa","Depletion","Uend", "q")#
barplot(ire_cr, ylim=c(-0.7,0.7), ylab="relative error", las=1)
rm(list=ls()); #
#if (Sys.info()["nodename"] =="sager")  setwd("~/Dropbox/LSRA/length_SRA/sim_est_lsra")#
setwd("/Users/catarinawor/Documents/length_SRA/simeval/")#
require(PBSmodelling)#
source("read.admb.R")#
Est_Tpl = "jmsra"#
Sim_Tpl = "simsra"#
## seed and store input and ouputs#
maxgrad_cr = NULL#
hat_cr = NULL#
ire_cr = NULL#
re_cr = NULL#
maxgrad_h = NULL#
hat_h = NULL#
ire_h = NULL#
re_h = NULL#
nsim = 1#
#for(s in 1:nsim) {#
#
##  set seed and Ft  #
#saveSim = paste(Sim_Tpl,'.dat',sep="")#
#cat( file=saveSim, "## written:",date(),"\n", append=T )#
#cat( file=saveSim, "## seed\n", append=T )#
#cat( file=saveSim, seeds[s], "\n", append=T )#
#cat( file=saveSim, "## Ft\n", append=T )#
#cat( file=saveSim, Ft, "\n", append=T )#
#
## run simulator#
system(paste('./',Sim_Tpl,' -ind ',Sim_Tpl,'.dat',sep=""), wait = TRUE)#
input = read.rep("true_data_lsra.rep")#
names(input)#
true_Ro = input$true_Ro#
true_reck = input$true_reck#
true_ct = input$true_Clt#
true_ut = input$true_ut#
#
true_utend = input$true_ut[length(true_ut)]#
true_nat = input$true_Nat#
true_sbt = input$true_sbt#
true_depl = input$true_depl#
true_rt = true_nat[,1]#
true_q = input$true_q#
## run estimator#
system(paste('./',Est_Tpl,' -ind ',Est_Tpl,'.dat',sep=""), wait = TRUE)#
out_cr = read.admb(Est_Tpl)#
names(out_cr)#
## save sim-est outputs#
maxgrad_cr <- rbind(maxgrad_cr, out_cr$fit$maxgrad)#
##print(A$fit$std)#
truePars = c(true_Ro,true_reck,true_depl[length(true_depl)],true_utend,true_q) #need to output q in SRasim#
ihat_cr = c(out_cr$Ro,out_cr$kappa,out_cr$depletion,out_cr$maxUy[length(out_cr$maxUy)],out_cr$q)#
temp_ire_cr = (ihat_cr - truePars) / truePars#
ire_cr <- rbind(ire_cr, temp_ire_cr)#
#
hat_cr <- rbind(hat_cr, ihat_cr)#
#
valid_maxgrad_cr = which(maxgrad_cr <= 0.0001)#
valid_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2)#
valid_grad_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2 & maxgrad_cr <= 0.0001)#
#if(s==nsim) { cat("# Valid Sim=", length(valid_grad_cr)) }#
#
#file.remove("simsra.dat")#
#
#}#
#
names(out_cr)#
names(input)#
#
plot_re = function(itheta,ivalid,h_cr,legend=T)  {#
  colnames(itheta) = c("ro","kappa","Depletion","Uend", "q")#
  boxplot(itheta[ivalid,], ylim=c(-0.7,0.7), ylab="relative error", las=1)#
  validSim = length(ivalid)#
  abline(h=0)#
  if(legend == T) {#
    #mtext(side=3,line=0,paste("steepness=",h_cr," Ft=","updowm"," simSigR=",0.6," simSS=","na," trueDepl=", round(trueDepl,2),"\n",#
    #                          "simObsErr=",tau," Mt=",Mtpattern," Vul=",vapattern, " NSim=",validSim,"\n", "cvl=", l1cv," sigVul=", sigVul, #
    #                          " SimRhoR=",round(rhoR,2)," Fmsy=",round(Fmsy,3),"x",xF," true cr/h =",round(cr,3),"/",h ))#
  }#
  else#
    mtext(side=3,line=0,paste("steepness=",h_cr," NSim=",validSim))#
}#
# pdflabel = paste("simF",Ftpattern,"iRE",".pdf",sep="_")#
#
#pdf(file=pdflabel) #
#
par(mfcol=c(1,1),mar=c(4,1,1,1),oma=c(0,2,2.5,0), las=1)#
plot_re(ire_cr,valid_maxgrad_cr,"CR",T)#
#
ire_cr[valid_maxgrad_cr,]#
#
colnames(ire_cr) = c("ro","kappa","Depletion","Uend", "q")#
barplot(ire_cr, ylim=c(-0.7,0.7), ylab="relative error", las=1)
rm(list=ls()); #
#if (Sys.info()["nodename"] =="sager")  setwd("~/Dropbox/LSRA/length_SRA/sim_est_lsra")#
setwd("/Users/catarinawor/Documents/length_SRA/simeval/")#
require(PBSmodelling)#
source("read.admb.R")#
Est_Tpl = "jmsra"#
Sim_Tpl = "simsra"#
#
## seed and store input and ouputs#
maxgrad_cr = NULL#
hat_cr = NULL#
ire_cr = NULL#
re_cr = NULL#
maxgrad_h = NULL#
hat_h = NULL#
ire_h = NULL#
re_h = NULL#
nsim = 50#
for(s in 1:nsim) {#
#
##  set seed and Ft  #
#saveSim = paste(Sim_Tpl,'.dat',sep="")#
#cat( file=saveSim, "## written:",date(),"\n", append=T )#
#cat( file=saveSim, "## seed\n", append=T )#
#cat( file=saveSim, seeds[s], "\n", append=T )#
#cat( file=saveSim, "## Ft\n", append=T )#
#cat( file=saveSim, Ft, "\n", append=T )#
#
## run simulator#
system(paste('./',Sim_Tpl,' -ind ',Sim_Tpl,'.dat',sep=""), wait = TRUE)#
input = read.rep("true_data_lsra.rep")#
names(input)#
true_Ro = input$true_Ro#
true_reck = input$true_reck#
true_ct = input$true_Clt#
true_ut = input$true_ut#
#
true_utend = input$true_ut[length(true_ut)]#
true_nat = input$true_Nat#
true_sbt = input$true_sbt#
true_depl = input$true_depl#
true_rt = true_nat[,1]#
true_q = input$true_q#
## run estimator#
system(paste('./',Est_Tpl,' -ind ',Est_Tpl,'.dat',sep=""), wait = TRUE)#
out_cr = read.admb(Est_Tpl)#
names(out_cr)#
## save sim-est outputs#
maxgrad_cr <- rbind(maxgrad_cr, out_cr$fit$maxgrad)#
##print(A$fit$std)#
truePars = c(true_Ro,true_reck,true_depl[length(true_depl)],true_utend,true_q) #need to output q in SRasim#
ihat_cr = c(out_cr$Ro,out_cr$kappa,out_cr$depletion,out_cr$maxUy[length(out_cr$maxUy)],out_cr$q)#
temp_ire_cr = (ihat_cr - truePars) / truePars#
ire_cr <- rbind(ire_cr, temp_ire_cr)#
#
hat_cr <- rbind(hat_cr, ihat_cr)#
#
valid_maxgrad_cr = which(maxgrad_cr <= 0.0001)#
valid_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2)#
valid_grad_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2 & maxgrad_cr <= 0.0001)#
#if(s==nsim) { cat("# Valid Sim=", length(valid_grad_cr)) }#
#
#file.remove("simsra.dat")#
#
}#
#
names(out_cr)#
names(input)#
#
plot_re = function(itheta,ivalid,h_cr,legend=T)  {#
  colnames(itheta) = c("ro","kappa","Depletion","Uend", "q")#
  boxplot(itheta[ivalid,], ylim=c(-0.7,0.7), ylab="relative error", las=1)#
  validSim = length(ivalid)#
  abline(h=0)#
  if(legend == T) {#
    #mtext(side=3,line=0,paste("steepness=",h_cr," Ft=","updowm"," simSigR=",0.6," simSS=","na," trueDepl=", round(trueDepl,2),"\n",#
    #                          "simObsErr=",tau," Mt=",Mtpattern," Vul=",vapattern, " NSim=",validSim,"\n", "cvl=", l1cv," sigVul=", sigVul, #
    #                          " SimRhoR=",round(rhoR,2)," Fmsy=",round(Fmsy,3),"x",xF," true cr/h =",round(cr,3),"/",h ))#
  }#
  else#
    mtext(side=3,line=0,paste("steepness=",h_cr," NSim=",validSim))#
}#
# pdflabel = paste("simF",Ftpattern,"iRE",".pdf",sep="_")#
#
#pdf(file=pdflabel) #
#
par(mfcol=c(1,1),mar=c(4,1,1,1),oma=c(0,2,2.5,0), las=1)#
plot_re(ire_cr,valid_maxgrad_cr,"CR",T)
rm(list=ls()); #
#if (Sys.info()["nodename"] =="sager")  setwd("~/Dropbox/LSRA/length_SRA/sim_est_lsra")#
setwd("/Users/catarinawor/Documents/length_SRA/simeval/")#
require(PBSmodelling)#
source("read.admb.R")#
Est_Tpl = "jmsra"#
Sim_Tpl = "simsra"#
#
## seed and store input and ouputs#
maxgrad_cr = NULL#
hat_cr = NULL#
ire_cr = NULL#
re_cr = NULL#
maxgrad_h = NULL#
hat_h = NULL#
ire_h = NULL#
re_h = NULL#
nsim = 500#
for(s in 1:nsim) {#
#
##  set seed and Ft  #
#saveSim = paste(Sim_Tpl,'.dat',sep="")#
#cat( file=saveSim, "## written:",date(),"\n", append=T )#
#cat( file=saveSim, "## seed\n", append=T )#
#cat( file=saveSim, seeds[s], "\n", append=T )#
#cat( file=saveSim, "## Ft\n", append=T )#
#cat( file=saveSim, Ft, "\n", append=T )#
#
## run simulator#
system(paste('./',Sim_Tpl,' -ind ',Sim_Tpl,'.dat',sep=""), wait = TRUE)#
input = read.rep("true_data_lsra.rep")#
names(input)#
true_Ro = input$true_Ro#
true_reck = input$true_reck#
true_ct = input$true_Clt#
true_ut = input$true_ut#
#
true_utend = input$true_ut[length(true_ut)]#
true_nat = input$true_Nat#
true_sbt = input$true_sbt#
true_depl = input$true_depl#
true_rt = true_nat[,1]#
true_q = input$true_q#
## run estimator#
system(paste('./',Est_Tpl,' -ind ',Est_Tpl,'.dat',sep=""), wait = TRUE)#
out_cr = read.admb(Est_Tpl)#
names(out_cr)#
## save sim-est outputs#
maxgrad_cr <- rbind(maxgrad_cr, out_cr$fit$maxgrad)#
##print(A$fit$std)#
truePars = c(true_Ro,true_reck,true_depl[length(true_depl)],true_utend,true_q) #need to output q in SRasim#
ihat_cr = c(out_cr$Ro,out_cr$kappa,out_cr$depletion,out_cr$maxUy[length(out_cr$maxUy)],out_cr$q)#
temp_ire_cr = (ihat_cr - truePars) / truePars#
ire_cr <- rbind(ire_cr, temp_ire_cr)#
#
hat_cr <- rbind(hat_cr, ihat_cr)#
#
valid_maxgrad_cr = which(maxgrad_cr <= 0.0001)#
valid_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2)#
valid_grad_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2 & maxgrad_cr <= 0.0001)#
#if(s==nsim) { cat("# Valid Sim=", length(valid_grad_cr)) }#
#
#file.remove("simsra.dat")#
#
}#
#
names(out_cr)#
names(input)#
#
plot_re = function(itheta,ivalid,h_cr,legend=T)  {#
  colnames(itheta) = c("ro","kappa","Depletion","Uend", "q")#
  boxplot(itheta[ivalid,], ylim=c(-0.7,0.7), ylab="relative error", las=1)#
  validSim = length(ivalid)#
  abline(h=0)#
  if(legend == T) {#
    #mtext(side=3,line=0,paste("steepness=",h_cr," Ft=","updowm"," simSigR=",0.6," simSS=","na," trueDepl=", round(trueDepl,2),"\n",#
    #                          "simObsErr=",tau," Mt=",Mtpattern," Vul=",vapattern, " NSim=",validSim,"\n", "cvl=", l1cv," sigVul=", sigVul, #
    #                          " SimRhoR=",round(rhoR,2)," Fmsy=",round(Fmsy,3),"x",xF," true cr/h =",round(cr,3),"/",h ))#
  }#
  else#
    mtext(side=3,line=0,paste("steepness=",h_cr," NSim=",validSim))#
}
par(mfcol=c(1,1),mar=c(4,1,1,1),oma=c(0,2,2.5,0), las=1)#
plot_re(ire_cr,valid_maxgrad_cr,"CR",T)
valid_maxgrad_cr
rm(list=ls()); #
#if (Sys.info()["nodename"] =="sager")  setwd("~/Dropbox/LSRA/length_SRA/sim_est_lsra")#
setwd("/Users/catarinawor/Documents/length_SRA/simeval/")#
require(PBSmodelling)#
source("read.admb.R")#
Est_Tpl = "jmsra"#
Sim_Tpl = "simsra"#
#
## seed and store input and ouputs#
maxgrad_cr = NULL#
hat_cr = NULL#
ire_cr = NULL#
re_cr = NULL#
maxgrad_h = NULL#
hat_h = NULL#
ire_h = NULL#
re_h = NULL#
nsim = 1#
#for(s in 1:nsim) {#
#
##  set seed and Ft  #
#saveSim = paste(Sim_Tpl,'.dat',sep="")#
#cat( file=saveSim, "## written:",date(),"\n", append=T )#
#cat( file=saveSim, "## seed\n", append=T )#
#cat( file=saveSim, seeds[s], "\n", append=T )#
#cat( file=saveSim, "## Ft\n", append=T )#
#cat( file=saveSim, Ft, "\n", append=T )#
#
## run simulator#
system(paste('./',Sim_Tpl,' -ind ',Sim_Tpl,'.dat',sep=""), wait = TRUE)#
input = read.rep("true_data_lsra.rep")#
names(input)#
true_Ro = input$true_Ro#
true_reck = input$true_reck#
true_ct = input$true_Clt#
true_ut = input$true_ut#
#
true_utend = input$true_ut[length(true_ut)]#
true_nat = input$true_Nat#
true_sbt = input$true_sbt#
true_depl = input$true_depl#
true_rt = true_nat[,1]#
true_q = input$true_q#
## run estimator#
system(paste('./',Est_Tpl,' -ind ',Est_Tpl,'.dat',sep=""), wait = TRUE)#
out_cr = read.admb(Est_Tpl)#
names(out_cr)#
## save sim-est outputs#
maxgrad_cr <- rbind(maxgrad_cr, out_cr$fit$maxgrad)#
##print(A$fit$std)#
truePars = c(true_Ro,true_reck,true_depl[length(true_depl)],true_utend,true_q) #need to output q in SRasim#
ihat_cr = c(out_cr$Ro,out_cr$kappa,out_cr$depletion,out_cr$maxUy[length(out_cr$maxUy)],out_cr$q)#
temp_ire_cr = (ihat_cr - truePars) / truePars#
ire_cr <- rbind(ire_cr, temp_ire_cr)#
#
hat_cr <- rbind(hat_cr, ihat_cr)#
#
valid_maxgrad_cr = which(maxgrad_cr <= 0.0001)#
valid_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2)#
valid_grad_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2 & maxgrad_cr <= 0.0001)#
#if(s==nsim) { cat("# Valid Sim=", length(valid_grad_cr)) }#
#
#file.remove("simsra.dat")#
#
#}
colnames(ire_cr) = c("ro","kappa","Depletion","Uend", "q")#
barplot(ire_cr, ylim=c(-0.7,0.7), ylab="relative error", las=1)
u<-scan()
plot(u)
u<-scan()
u<-scan()
rm(list=ls()); #
#if (Sys.info()["nodename"] =="sager")  setwd("~/Dropbox/LSRA/length_SRA/sim_est_lsra")#
setwd("/Users/catarinawor/Documents/length_SRA/simeval/")#
require(PBSmodelling)#
source("read.admb.R")#
Est_Tpl = "jmsra"#
Sim_Tpl = "simsra"#
#
## seed and store input and ouputs#
maxgrad_cr = NULL#
hat_cr = NULL#
ire_cr = NULL#
re_cr = NULL#
maxgrad_h = NULL#
hat_h = NULL#
ire_h = NULL#
re_h = NULL#
nsim = 1#
#for(s in 1:nsim) {#
#
##  set seed and Ft  #
#saveSim = paste(Sim_Tpl,'.dat',sep="")#
#cat( file=saveSim, "## written:",date(),"\n", append=T )#
#cat( file=saveSim, "## seed\n", append=T )#
#cat( file=saveSim, seeds[s], "\n", append=T )#
#cat( file=saveSim, "## Ft\n", append=T )#
#cat( file=saveSim, Ft, "\n", append=T )#
#
## run simulator#
system(paste('./',Sim_Tpl,' -ind ',Sim_Tpl,'.dat',sep=""), wait = TRUE)#
input = read.rep("true_data_lsra.rep")#
names(input)#
true_Ro = input$true_Ro#
true_reck = input$true_reck#
true_ct = input$true_Clt#
true_ut = input$true_ut#
#
true_utend = input$true_ut[length(true_ut)]#
true_nat = input$true_Nat#
true_sbt = input$true_sbt#
true_depl = input$true_depl#
true_rt = true_nat[,1]#
true_q = input$true_q#
## run estimator#
system(paste('./',Est_Tpl,' -ind ',Est_Tpl,'.dat',sep=""), wait = TRUE)#
out_cr = read.admb(Est_Tpl)#
names(out_cr)#
## save sim-est outputs#
maxgrad_cr <- rbind(maxgrad_cr, out_cr$fit$maxgrad)#
##print(A$fit$std)#
truePars = c(true_Ro,true_reck,true_depl[length(true_depl)],true_utend,true_q) #need to output q in SRasim#
ihat_cr = c(out_cr$Ro,out_cr$kappa,out_cr$depletion,out_cr$maxUy[length(out_cr$maxUy)],out_cr$q)#
temp_ire_cr = (ihat_cr - truePars) / truePars#
ire_cr <- rbind(ire_cr, temp_ire_cr)#
#
hat_cr <- rbind(hat_cr, ihat_cr)#
#
valid_maxgrad_cr = which(maxgrad_cr <= 0.0001)#
valid_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2)#
valid_grad_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2 & maxgrad_cr <= 0.0001)#
#if(s==nsim) { cat("# Valid Sim=", length(valid_grad_cr)) }#
#
#file.remove("simsra.dat")#
#
#}
colnames(ire_cr) = c("ro","kappa","Depletion","Uend", "q")#
barplot(ire_cr, ylim=c(-0.7,0.7), ylab="relative error", las=1)
rm(list=ls()); #
#if (Sys.info()["nodename"] =="sager")  setwd("~/Dropbox/LSRA/length_SRA/sim_est_lsra")#
setwd("/Users/catarinawor/Documents/length_SRA/simeval/")#
require(PBSmodelling)#
source("read.admb.R")#
Est_Tpl = "jmsra"#
Sim_Tpl = "simsra"#
#
## seed and store input and ouputs#
maxgrad_cr = NULL#
hat_cr = NULL#
ire_cr = NULL#
re_cr = NULL#
maxgrad_h = NULL#
hat_h = NULL#
ire_h = NULL#
re_h = NULL#
nsim = 100#
for(s in 1:nsim) {#
#
##  set seed and Ft  #
#saveSim = paste(Sim_Tpl,'.dat',sep="")#
#cat( file=saveSim, "## written:",date(),"\n", append=T )#
#cat( file=saveSim, "## seed\n", append=T )#
#cat( file=saveSim, seeds[s], "\n", append=T )#
#cat( file=saveSim, "## Ft\n", append=T )#
#cat( file=saveSim, Ft, "\n", append=T )#
#
## run simulator#
system(paste('./',Sim_Tpl,' -ind ',Sim_Tpl,'.dat',sep=""), wait = TRUE)#
input = read.rep("true_data_lsra.rep")#
names(input)#
true_Ro = input$true_Ro#
true_reck = input$true_reck#
true_ct = input$true_Clt#
true_ut = input$true_ut#
#
true_utend = input$true_ut[length(true_ut)]#
true_nat = input$true_Nat#
true_sbt = input$true_sbt#
true_depl = input$true_depl#
true_rt = true_nat[,1]#
true_q = input$true_q#
## run estimator#
system(paste('./',Est_Tpl,' -ind ',Est_Tpl,'.dat',sep=""), wait = TRUE)#
out_cr = read.admb(Est_Tpl)#
names(out_cr)#
## save sim-est outputs#
maxgrad_cr <- rbind(maxgrad_cr, out_cr$fit$maxgrad)#
##print(A$fit$std)#
truePars = c(true_Ro,true_reck,true_depl[length(true_depl)],true_utend,true_q) #need to output q in SRasim#
ihat_cr = c(out_cr$Ro,out_cr$kappa,out_cr$depletion,out_cr$maxUy[length(out_cr$maxUy)],out_cr$q)#
temp_ire_cr = (ihat_cr - truePars) / truePars#
ire_cr <- rbind(ire_cr, temp_ire_cr)#
#
hat_cr <- rbind(hat_cr, ihat_cr)#
#
valid_maxgrad_cr = which(maxgrad_cr <= 0.0001)#
valid_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2)#
valid_grad_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2 & maxgrad_cr <= 0.0001)#
#if(s==nsim) { cat("# Valid Sim=", length(valid_grad_cr)) }#
#
#file.remove("simsra.dat")#
#
}#
#
names(out_cr)#
names(input)#
#
plot_re = function(itheta,ivalid,h_cr,legend=T)  {#
  colnames(itheta) = c("ro","kappa","Depletion","Uend", "q")#
  boxplot(itheta[ivalid,], ylim=c(-0.7,0.7), ylab="relative error", las=1)#
  validSim = length(ivalid)#
  abline(h=0)#
  if(legend == T) {#
    #mtext(side=3,line=0,paste("steepness=",h_cr," Ft=","updowm"," simSigR=",0.6," simSS=","na," trueDepl=", round(trueDepl,2),"\n",#
    #                          "simObsErr=",tau," Mt=",Mtpattern," Vul=",vapattern, " NSim=",validSim,"\n", "cvl=", l1cv," sigVul=", sigVul, #
    #                          " SimRhoR=",round(rhoR,2)," Fmsy=",round(Fmsy,3),"x",xF," true cr/h =",round(cr,3),"/",h ))#
  }#
  else#
    mtext(side=3,line=0,paste("steepness=",h_cr," NSim=",validSim))#
}
par(mfcol=c(1,1),mar=c(4,1,1,1),oma=c(0,2,2.5,0), las=1)#
plot_re(ire_cr,valid_maxgrad_cr,"CR",T)
valid_maxgrad_cr
rm(list=ls()); #
#if (Sys.info()["nodename"] =="sager")  setwd("~/Dropbox/LSRA/length_SRA/sim_est_lsra")#
setwd("/Users/catarinawor/Documents/length_SRA/simeval/")#
require(PBSmodelling)#
source("read.admb.R")#
Est_Tpl = "jmsra"#
Sim_Tpl = "simsra"#
#
## seed and store input and ouputs#
maxgrad_cr = NULL#
hat_cr = NULL#
ire_cr = NULL#
re_cr = NULL#
maxgrad_h = NULL#
hat_h = NULL#
ire_h = NULL#
re_h = NULL#
nsim = 100#
for(s in 1:nsim) {#
#
##  set seed and Ft  #
#saveSim = paste(Sim_Tpl,'.dat',sep="")#
#cat( file=saveSim, "## written:",date(),"\n", append=T )#
#cat( file=saveSim, "## seed\n", append=T )#
#cat( file=saveSim, seeds[s], "\n", append=T )#
#cat( file=saveSim, "## Ft\n", append=T )#
#cat( file=saveSim, Ft, "\n", append=T )#
#
## run simulator#
system(paste('./',Sim_Tpl,' -ind ',Sim_Tpl,'.dat',sep=""), wait = TRUE)#
input = read.rep("true_data_lsra.rep")#
names(input)#
true_Ro = input$true_Ro#
true_reck = input$true_reck#
true_ct = input$true_Clt#
true_ut = input$true_ut#
#
true_utend = input$true_ut[length(true_ut)]#
true_nat = input$true_Nat#
true_sbt = input$true_sbt#
true_depl = input$true_depl#
true_rt = true_nat[,1]#
true_q = input$true_q#
## run estimator#
system(paste('./',Est_Tpl,' -ind ',Est_Tpl,'.dat',sep=""), wait = TRUE)#
out_cr = read.admb(Est_Tpl)#
names(out_cr)#
## save sim-est outputs#
maxgrad_cr <- rbind(maxgrad_cr, out_cr$fit$maxgrad)#
##print(A$fit$std)#
truePars = c(true_Ro,true_reck,true_depl[length(true_depl)],true_utend,true_q) #need to output q in SRasim#
ihat_cr = c(out_cr$Ro,out_cr$kappa,out_cr$depletion,out_cr$maxUy[length(out_cr$maxUy)],out_cr$q)#
temp_ire_cr = (ihat_cr - truePars) / truePars#
ire_cr <- rbind(ire_cr, temp_ire_cr)#
#
hat_cr <- rbind(hat_cr, ihat_cr)#
#
valid_maxgrad_cr = which(maxgrad_cr <= 0.0001)#
valid_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2)#
valid_grad_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2 & maxgrad_cr <= 0.0001)#
#if(s==nsim) { cat("# Valid Sim=", length(valid_grad_cr)) }#
#
#file.remove("simsra.dat")#
#
}#
#
names(out_cr)#
names(input)#
#
plot_re = function(itheta,ivalid,h_cr,legend=T)  {#
  colnames(itheta) = c("ro","kappa","Depletion","Uend", "q")#
  boxplot(itheta[ivalid,], ylim=c(-0.7,0.7), ylab="relative error", las=1)#
  validSim = length(ivalid)#
  abline(h=0)#
  if(legend == T) {#
    #mtext(side=3,line=0,paste("steepness=",h_cr," Ft=","updowm"," simSigR=",0.6," simSS=","na," trueDepl=", round(trueDepl,2),"\n",#
    #                          "simObsErr=",tau," Mt=",Mtpattern," Vul=",vapattern, " NSim=",validSim,"\n", "cvl=", l1cv," sigVul=", sigVul, #
    #                          " SimRhoR=",round(rhoR,2)," Fmsy=",round(Fmsy,3),"x",xF," true cr/h =",round(cr,3),"/",h ))#
  }#
  else#
    mtext(side=3,line=0,paste("steepness=",h_cr," NSim=",validSim))#
}#
# pdflabel = paste("simF",Ftpattern,"iRE",".pdf",sep="_")#
#
#pdf(file=pdflabel) #
#
par(mfcol=c(1,1),mar=c(4,1,1,1),oma=c(0,2,2.5,0), las=1)#
plot_re(ire_cr,valid_maxgrad_cr,"CR",T)
rm(list=ls()); #
#if (Sys.info()["nodename"] =="sager")  setwd("~/Dropbox/LSRA/length_SRA/sim_est_lsra")#
setwd("/Users/catarinawor/Documents/length_SRA/simeval/")#
require(PBSmodelling)#
source("read.admb.R")#
Est_Tpl = "jmsra"#
Sim_Tpl = "simsra"#
#
## seed and store input and ouputs#
maxgrad_cr = NULL#
hat_cr = NULL#
ire_cr = NULL#
re_cr = NULL#
maxgrad_h = NULL#
hat_h = NULL#
ire_h = NULL#
re_h = NULL#
nsim = 100#
for(s in 1:nsim) {#
#
##  set seed and Ft  #
#saveSim = paste(Sim_Tpl,'.dat',sep="")#
#cat( file=saveSim, "## written:",date(),"\n", append=T )#
#cat( file=saveSim, "## seed\n", append=T )#
#cat( file=saveSim, seeds[s], "\n", append=T )#
#cat( file=saveSim, "## Ft\n", append=T )#
#cat( file=saveSim, Ft, "\n", append=T )#
#
## run simulator#
system(paste('./',Sim_Tpl,' -ind ',Sim_Tpl,'.dat',sep=""), wait = TRUE)#
input = read.rep("true_data_lsra.rep")#
names(input)#
true_Ro = input$true_Ro#
true_reck = input$true_reck#
true_ct = input$true_Clt#
true_ut = input$true_ut#
#
true_utend = input$true_ut[length(true_ut)]#
true_nat = input$true_Nat#
true_sbt = input$true_sbt#
true_depl = input$true_depl#
true_rt = true_nat[,1]#
true_q = input$true_q#
## run estimator#
system(paste('./',Est_Tpl,' -ind ',Est_Tpl,'.dat',sep=""), wait = TRUE)#
out_cr = read.admb(Est_Tpl)#
names(out_cr)#
## save sim-est outputs#
maxgrad_cr <- rbind(maxgrad_cr, out_cr$fit$maxgrad)#
##print(A$fit$std)#
truePars = c(true_Ro,true_reck,true_depl[length(true_depl)],true_utend,true_q) #need to output q in SRasim#
ihat_cr = c(out_cr$Ro,out_cr$kappa,out_cr$depletion,out_cr$maxUy[length(out_cr$maxUy)],out_cr$q)#
temp_ire_cr = (ihat_cr - truePars) / truePars#
ire_cr <- rbind(ire_cr, temp_ire_cr)#
#
hat_cr <- rbind(hat_cr, ihat_cr)#
#
valid_maxgrad_cr = which(maxgrad_cr <= 0.0001)#
valid_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2)#
valid_grad_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2 & maxgrad_cr <= 0.0001)#
#if(s==nsim) { cat("# Valid Sim=", length(valid_grad_cr)) }#
#
#file.remove("simsra.dat")#
#
}#
#
names(out_cr)#
names(input)#
#
plot_re = function(itheta,ivalid,h_cr,legend=T)  {#
  colnames(itheta) = c("ro","kappa","Depletion","Uend", "q")#
  boxplot(itheta[ivalid,], ylim=c(-0.7,0.7), ylab="relative error", las=1)#
  validSim = length(ivalid)#
  abline(h=0)#
  if(legend == T) {#
    #mtext(side=3,line=0,paste("steepness=",h_cr," Ft=","updowm"," simSigR=",0.6," simSS=","na," trueDepl=", round(trueDepl,2),"\n",#
    #                          "simObsErr=",tau," Mt=",Mtpattern," Vul=",vapattern, " NSim=",validSim,"\n", "cvl=", l1cv," sigVul=", sigVul, #
    #                          " SimRhoR=",round(rhoR,2)," Fmsy=",round(Fmsy,3),"x",xF," true cr/h =",round(cr,3),"/",h ))#
  }#
  else#
    mtext(side=3,line=0,paste("steepness=",h_cr," NSim=",validSim))#
}#
# pdflabel = paste("simF",Ftpattern,"iRE",".pdf",sep="_")#
#
#pdf(file=pdflabel) #
#
par(mfcol=c(1,1),mar=c(4,1,1,1),oma=c(0,2,2.5,0), las=1)#
plot_re(ire_cr,valid_maxgrad_cr,"CR",T)
rm(list=ls()); #
#if (Sys.info()["nodename"] =="sager")  setwd("~/Dropbox/LSRA/length_SRA/sim_est_lsra")#
setwd("/Users/catarinawor/Documents/length_SRA/simeval/")#
require(PBSmodelling)#
source("read.admb.R")#
Est_Tpl = "jmsra"#
Sim_Tpl = "simsra"#
#
## seed and store input and ouputs#
maxgrad_cr = NULL#
hat_cr = NULL#
ire_cr = NULL#
re_cr = NULL#
maxgrad_h = NULL#
hat_h = NULL#
ire_h = NULL#
re_h = NULL#
nsim = 100#
for(s in 1:nsim) {#
#
##  set seed and Ft  #
#saveSim = paste(Sim_Tpl,'.dat',sep="")#
#cat( file=saveSim, "## written:",date(),"\n", append=T )#
#cat( file=saveSim, "## seed\n", append=T )#
#cat( file=saveSim, seeds[s], "\n", append=T )#
#cat( file=saveSim, "## Ft\n", append=T )#
#cat( file=saveSim, Ft, "\n", append=T )#
#
## run simulator#
system(paste('./',Sim_Tpl,' -ind ',Sim_Tpl,'.dat',sep=""), wait = TRUE)#
input = read.rep("true_data_lsra.rep")#
names(input)#
true_Ro = input$true_Ro#
true_reck = input$true_reck#
true_ct = input$true_Clt#
true_ut = input$true_ut#
#
true_utend = input$true_ut[length(true_ut)]#
true_nat = input$true_Nat#
true_sbt = input$true_sbt#
true_depl = input$true_depl#
true_rt = true_nat[,1]#
true_q = input$true_q#
## run estimator#
system(paste('./',Est_Tpl,' -ind ',Est_Tpl,'.dat',sep=""), wait = TRUE)#
out_cr = read.admb(Est_Tpl)#
names(out_cr)#
## save sim-est outputs#
maxgrad_cr <- rbind(maxgrad_cr, out_cr$fit$maxgrad)#
##print(A$fit$std)#
truePars = c(true_Ro,true_reck,true_depl[length(true_depl)],true_utend,true_q) #need to output q in SRasim#
ihat_cr = c(out_cr$Ro,out_cr$kappa,out_cr$depletion,out_cr$maxUy[length(out_cr$maxUy)],out_cr$q)#
temp_ire_cr = (ihat_cr - truePars) / truePars#
ire_cr <- rbind(ire_cr, temp_ire_cr)#
#
hat_cr <- rbind(hat_cr, ihat_cr)#
#
valid_maxgrad_cr = which(maxgrad_cr <= 0.0001)#
valid_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2)#
valid_grad_cr = which( hat_cr[,2] >= 2 & hat_cr[,2] <= true_reck*2 & maxgrad_cr <= 0.0001)#
#if(s==nsim) { cat("# Valid Sim=", length(valid_grad_cr)) }#
#
#file.remove("simsra.dat")#
#
}#
#
names(out_cr)#
names(input)#
#
plot_re = function(itheta,ivalid,h_cr,legend=T)  {#
  colnames(itheta) = c("ro","kappa","Depletion","Uend", "q")#
  boxplot(itheta[ivalid,], ylim=c(-0.7,0.7), ylab="relative error", las=1)#
  validSim = length(ivalid)#
  abline(h=0)#
  if(legend == T) {#
    #mtext(side=3,line=0,paste("steepness=",h_cr," Ft=","updowm"," simSigR=",0.6," simSS=","na," trueDepl=", round(trueDepl,2),"\n",#
    #                          "simObsErr=",tau," Mt=",Mtpattern," Vul=",vapattern, " NSim=",validSim,"\n", "cvl=", l1cv," sigVul=", sigVul, #
    #                          " SimRhoR=",round(rhoR,2)," Fmsy=",round(Fmsy,3),"x",xF," true cr/h =",round(cr,3),"/",h ))#
  }#
  else#
    mtext(side=3,line=0,paste("steepness=",h_cr," NSim=",validSim))#
}#
# pdflabel = paste("simF",Ftpattern,"iRE",".pdf",sep="_")#
#
#pdf(file=pdflabel) #
#
par(mfcol=c(1,1),mar=c(4,1,1,1),oma=c(0,2,2.5,0), las=1)#
plot_re(ire_cr,valid_maxgrad_cr,"CR",T)
